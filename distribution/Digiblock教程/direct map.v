/*
 * Generated by Digiblock. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DemuxBus3 #(
    parameter Bits = 2
)
(
    output [2:0] out_0,
    output [2:0] out_1,
    output [2:0] out_2,
    output [2:0] out_3,
    output [2:0] out_4,
    output [2:0] out_5,
    output [2:0] out_6,
    output [2:0] out_7,
    input [2:0] sel,
    input [2:0] in
);
    assign out_0 = (sel == 3'h0)? in : 3'h0;
    assign out_1 = (sel == 3'h1)? in : 3'h0;
    assign out_2 = (sel == 3'h2)? in : 3'h0;
    assign out_3 = (sel == 3'h3)? in : 3'h0;
    assign out_4 = (sel == 3'h4)? in : 3'h0;
    assign out_5 = (sel == 3'h5)? in : 3'h0;
    assign out_6 = (sel == 3'h6)? in : 3'h0;
    assign out_7 = (sel == 3'h7)? in : 3'h0;
endmodule
module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule
module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule
module Demux3
(
    output [0:0] out_0,
    output [0:0] out_1,
    output [0:0] out_2,
    output [0:0] out_3,
    output [0:0] out_4,
    output [0:0] out_5,
    output [0:0] out_6,
    output [0:0] out_7,
    input [2:0] sel,
    input [0:0] in
);
    assign out_0 = (sel == 3'h0)? in : 1'h0;
    assign out_1 = (sel == 3'h1)? in : 1'h0;
    assign out_2 = (sel == 3'h2)? in : 1'h0;
    assign out_3 = (sel == 3'h3)? in : 1'h0;
    assign out_4 = (sel == 3'h4)? in : 1'h0;
    assign out_5 = (sel == 3'h5)? in : 1'h0;
    assign out_6 = (sel == 3'h6)? in : 1'h0;
    assign out_7 = (sel == 3'h7)? in : 1'h0;
endmodule
module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule
module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule
module Mux_8x1
(
    input [2:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    input in_4,
    input in_5,
    input in_6,
    input in_7,
    output reg out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule
module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule
module DIG_RAMDualPort
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
  input [(AddrBits-1):0] A,
  input [(Bits-1):0] Din,
  input str,
  input C,
  input ld,
  output [(Bits-1):0] D
);
  reg [(Bits-1):0] memory[0:((1 << AddrBits) - 1)];

  assign D = ld? memory[A] : 'hz;

  always @ (posedge C) begin
    if (str)
      memory[A] <= Din;
  end
endmodule
module DriverInvBus#(
    parameter Bits = 2
)
(
    input [(Bits-1):0] in,
    input sel,
    output [(Bits-1):0] out
);
    assign out = (sel == 1'b0)? in : {Bits{1'bz}};
endmodule
