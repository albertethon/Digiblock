/*
 * Generated by Digiblock. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule
module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule
module DIG_RAMDualPort
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
  input [(AddrBits-1):0] A,
  input [(Bits-1):0] Din,
  input str,
  input C,
  input ld,
  output [(Bits-1):0] D
);
  reg [(Bits-1):0] memory[0:((1 << AddrBits) - 1)];

  assign D = ld? memory[A] : 'hz;

  always @ (posedge C) begin
    if (str)
      memory[A] <= Din;
  end
endmodule
module DIG_RegisterFile
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input [(Bits-1):0] Din,
    input we,
    input [(AddrBits-1):0] Rw,
    input C,
    input [(AddrBits-1):0] Ra,
    input [(AddrBits-1):0] Rb,
    output [(Bits-1):0] Da,
    output [(Bits-1):0] Db
);

    reg [(Bits-1):0] memory[0:((1 << AddrBits)-1)];

    assign Da = memory[Ra];
    assign Db = memory[Rb];

    always @ (posedge C) begin
        if (we)
            memory[Rw] <= Din;
    end
endmodule
module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule
module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule
module LogicalLeft #(
parameter Bits = 4,
parameter shiftBits=3
)
(
    input [(Bits-1):0] in,
    input [(shiftBits-1):0] shift,
    output [(Bits - 1):0] out
);

assign out = (in << shift);

endmodule
module DIG_Mul_unsigned #(
    parameter Bits = 1
)
(
    
      input [(Bits-1):0] a,
      input [(Bits-1):0] b,
      output [(Bits*2-1):0] mul
    
);
    assign mul = a * b;
endmodule
module RotateLeft #(
parameter Bits = 4,
parameter shiftBits=3
)
(
    input [(Bits-1):0] in,
    input [(shiftBits-1):0] shift,
    output [(Bits - 1):0] out
);

wire [(shiftBits-2):0] num;
assign num=shift[(shiftBits-2):0];
assign out = (in >> (Bits-num)| (in<<num));

endmodule
module LogicalRight #(
parameter Bits = 4,
parameter shiftBits=3
)
(
    input [(Bits-1):0] in,
    input [(shiftBits-1):0] shift,
    output [(Bits - 1):0] out
);

assign out = (in >> shift);

endmodule
module RotateRight #(
parameter Bits = 4,
parameter shiftBits=3
)
(
    input [(Bits-1):0] in,
    input [(shiftBits-1):0] shift,
    output [(Bits - 1):0] out
);

wire [(shiftBits-2):0] num;
assign num=shift[(shiftBits-2):0];
assign out = (in << (Bits-num)| (in>>num));

endmodule
module DIG_ROM_16X16_MROM (
    input [3:0] A,
    input sel,
    output reg [15:0] D
);
    reg [15:0] my_rom [0:15];

    always @ (*) begin
        if (~sel)
            D = 16'hz;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 16'h120;
        my_rom[1] = 16'h1100;
        my_rom[2] = 16'ha40;
        my_rom[3] = 16'h940;
        my_rom[4] = 16'h640;
        my_rom[5] = 16'h2c0;
        my_rom[6] = 16'h550;
        my_rom[7] = 16'h390;
        my_rom[8] = 16'h0;
        my_rom[9] = 16'h2350;
        my_rom[10] = 16'h4350;
        my_rom[11] = 16'h6350;
        my_rom[12] = 16'h8350;
        my_rom[13] = 16'ha350;
        my_rom[14] = 16'hc350;
        my_rom[15] = 16'he340;
    end
endmodule
module DIG_ROM_256X8_ROM (
    input [7:0] A,
    input sel,
    output reg [7:0] D
);
    reg [7:0] my_rom [0:17];

    always @ (*) begin
        if (~sel)
            D = 8'hz;
        else if (A > 8'h11)
            D = 8'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 8'h30;
        my_rom[1] = 8'h1;
        my_rom[2] = 8'h34;
        my_rom[3] = 8'h2;
        my_rom[4] = 8'h38;
        my_rom[5] = 8'h80;
        my_rom[6] = 8'h1;
        my_rom[7] = 8'h91;
        my_rom[8] = 8'h94;
        my_rom[9] = 8'h1;
        my_rom[10] = 8'hf9;
        my_rom[11] = 8'h1;
        my_rom[12] = 8'h12;
        my_rom[13] = 8'h10;
        my_rom[14] = 8'h10;
        my_rom[15] = 8'h7;
        my_rom[16] = 8'h50;
        my_rom[17] = 8'h1;
    end
endmodule
module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule
module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule
module DemuxBus2 #(
    parameter Bits = 2
)
(
    output [7:0] out_0,
    output [7:0] out_1,
    output [7:0] out_2,
    output [7:0] out_3,
    input [1:0] sel,
    input [7:0] in
);
    assign out_0 = (sel == 2'h0)? in : 8'h0;
    assign out_1 = (sel == 2'h1)? in : 8'h0;
    assign out_2 = (sel == 2'h2)? in : 8'h0;
    assign out_3 = (sel == 2'h3)? in : 8'h0;
endmodule
module Decoder2 (
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    input [1:0] sel
);
    assign out_0 = (sel == 2'h0)? 1'b1 : 1'b0;
    assign out_1 = (sel == 2'h1)? 1'b1 : 1'b0;
    assign out_2 = (sel == 2'h2)? 1'b1 : 1'b0;
    assign out_3 = (sel == 2'h3)? 1'b1 : 1'b0;
endmodule
module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule
module DIG_ROM_128X8_Drom (
    input [6:0] A,
    input sel,
    output reg [7:0] D
);
    reg [7:0] my_rom [0:17];

    always @ (*) begin
        if (~sel)
            D = 8'hz;
        else if (A > 7'h11)
            D = 8'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 8'h30;
        my_rom[1] = 8'h1;
        my_rom[2] = 8'h34;
        my_rom[3] = 8'h2;
        my_rom[4] = 8'h38;
        my_rom[5] = 8'h80;
        my_rom[6] = 8'h1;
        my_rom[7] = 8'h91;
        my_rom[8] = 8'h94;
        my_rom[9] = 8'h1;
        my_rom[10] = 8'hf9;
        my_rom[11] = 8'h1;
        my_rom[12] = 8'h12;
        my_rom[13] = 8'h10;
        my_rom[14] = 8'h10;
        my_rom[15] = 8'h7;
        my_rom[16] = 8'h50;
        my_rom[17] = 8'h1;
    end
endmodule
module Mux_4x1
(
    input [1:0] sel,
    input in_0,
    input in_1,
    input in_2,
    input in_3,
    output reg out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule

module microprogramIII (
  input [7:0] IN,
  input clock,
  input reset,
  output [7:0] OUT
);
  wire [6:0] s0;
  wire [7:0] Min;
  wire s1;
  wire clk;
  wire [7:0] s2;
  wire [7:0] Yin;
  wire s3;
  wire [7:0] s4;
  wire [7:0] Mout;
  wire memw;
  wire [7:0] Rin;
  wire regw;
  wire [1:0] Ra;
  wire [1:0] Rb;
  wire [7:0] Da;
  wire [7:0] Db;
  wire [1:0] Asel;
  wire [7:0] s_out;
  wire [7:0] s5;
  wire [2:0] Ssel;
  wire [7:0] IMM;
  wire [7:0] Xin;
  wire ENout;
  wire P1;
  wire [3:0] s6;
  wire [3:0] OP;
  wire [3:0] s7;
  wire [3:0] s8;
  wire [15:0] s9;
  wire [7:0] s10;
  wire [3:0] s11;
  wire [7:0] s12;
  wire [7:0] s13;
  wire \PC+1 ;
  wire s14;
  wire [2:0] ALUop;
  wire hlt;
  wire s15;
  wire s16;
  wire I_10;
  wire [3:0] s17;
  wire [7:0] s18;
  wire C_F;
  wire [7:0] s19;
  wire [7:0] s20;
  wire [7:0] s21;
  wire [7:0] s22;
  wire [3:0] s23;
  wire [7:0] s24;
  wire [7:0] s25;
  wire [7:0] s26;
  wire [15:0] s27;
  wire [7:0] s28;
  wire [7:0] s29;
  wire [7:0] s30;
  wire Z_F;
  wire C;
  wire Z;
  wire S;
  wire s31;
  wire [2:0] s32;
  wire [2:0] s33;
  assign s15 = (reset & clock);
  Mux_8x1_NBits #(
    .Bits(8)
  )
  Mux_8x1_NBits_i0 (
    .sel( Ssel ),
    .in_0( 8'b0 ),
    .in_1( Da ),
    .in_2( Mout ),
    .in_3( IN ),
    .in_4( IMM ),
    .in_5( Db ),
    .in_6( 8'b0 ),
    .in_7( 8'b0 ),
    .out( Xin )
  );
  // break
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i1 (
    .Set( 1'b0 ),
    .D( hlt ),
    .C( clk ),
    .Clr( s15 ),
    .Q( s16 )
  );
  assign clk = (clock | s16);
  // Dram
  DIG_RAMDualPort #(
    .Bits(8),
    .AddrBits(7)
  )
  DIG_RAMDualPort_i2 (
    .A( s0 ),
    .Din( Min ),
    .str( s1 ),
    .C( clk ),
    .ld( 1'b1 ),
    .D( s2 )
  );
  // regs
  DIG_RegisterFile #(
    .Bits(8),
    .AddrBits(2)
  )
  DIG_RegisterFile_i3 (
    .Din( Rin ),
    .we( regw ),
    .Rw( Ra ),
    .C( clk ),
    .Ra( Ra ),
    .Rb( Rb ),
    .Da( Da ),
    .Db( Db )
  );
  // MAR
  DIG_Register_BUS #(
    .Bits(4)
  )
  DIG_Register_BUS_i4 (
    .D( s7 ),
    .C( clk ),
    .en( 1'b1 ),
    .Q( s8 )
  );
  // PC
  DIG_Register_BUS #(
    .Bits(8)
  )
  DIG_Register_BUS_i5 (
    .D( s13 ),
    .C( clk ),
    .en( \PC+1  ),
    .Q( s10 )
  );
  DIG_Register_BUS #(
    .Bits(4)
  )
  DIG_Register_BUS_i6 (
    .D( s11 ),
    .C( clk ),
    .en( P1 ),
    .Q( s17 )
  );
  DIG_Register_BUS #(
    .Bits(8)
  )
  DIG_Register_BUS_i7 (
    .D( s_out ),
    .C( clk ),
    .en( ENout ),
    .Q( OUT )
  );
  DIG_Add #(
    .Bits(8)
  )
  DIG_Add_i8 (
    .a( Xin ),
    .b( Yin ),
    .c_i( 1'b0 ),
    .s( s18 ),
    .c_o( C_F )
  );
  DIG_Sub #(
    .Bits(8)
  )
  DIG_Sub_i9 (
    .a( Xin ),
    .b( Yin ),
    .c_i( 1'b0 ),
    .s( s19 )
  );
  assign s20 = (Xin & Yin);
  assign s21 = (Xin | Yin);
  assign s22 = (Xin ^ Yin);
  LogicalLeft #(
    .Bits(8),
    .shiftBits(4)
  )
  LogicalLeft_i10 (
    .in( Xin ),
    .shift( s23 ),
    .out( s24 )
  );
  Mux_8x1_NBits #(
    .Bits(8)
  )
  Mux_8x1_NBits_i11 (
    .sel( ALUop ),
    .in_0( Xin ),
    .in_1( s18 ),
    .in_2( s19 ),
    .in_3( s25 ),
    .in_4( s20 ),
    .in_5( s21 ),
    .in_6( s22 ),
    .in_7( s26 ),
    .out( s5 )
  );
  DIG_Mul_unsigned #(
    .Bits(8)
  )
  DIG_Mul_unsigned_i12 (
    .a( Xin ),
    .b( Yin ),
    .mul( s27 )
  );
  RotateLeft #(
    .Bits(8),
    .shiftBits(4)
  )
  RotateLeft_i13 (
    .in( Xin ),
    .shift( s23 ),
    .out( s28 )
  );
  LogicalRight #(
    .Bits(8),
    .shiftBits(4)
  )
  LogicalRight_i14 (
    .in( Xin ),
    .shift( s23 ),
    .out( s29 )
  );
  RotateRight #(
    .Bits(8),
    .shiftBits(4)
  )
  RotateRight_i15 (
    .in( Xin ),
    .shift( s23 ),
    .out( s30 )
  );
  // MROM
  DIG_ROM_16X16_MROM DIG_ROM_16X16_MROM_i16 (
    .A( s8 ),
    .sel( 1'b1 ),
    .D( s9 )
  );
  // ROM
  DIG_ROM_256X8_ROM DIG_ROM_256X8_ROM_i17 (
    .A( s10 ),
    .sel( 1'b1 ),
    .D( IMM )
  );
  DIG_Add #(
    .Bits(8)
  )
  DIG_Add_i18 (
    .a( 8'b1 ),
    .b( s10 ),
    .c_i( 1'b0 ),
    .s( s12 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i19 (
    .a( s5 ),
    .b( 8'b0 ),
    .\= ( Z_F )
  );
  assign Rb = s17[1:0];
  assign Ra = s17[3:2];
  assign s25 = s27[7:0];
  assign I_10 = (Rb[0] | Rb[1]);
  Mux_4x1_NBits #(
    .Bits(8)
  )
  Mux_4x1_NBits_i20 (
    .sel( Rb ),
    .in_0( s24 ),
    .in_1( s29 ),
    .in_2( s28 ),
    .in_3( s30 ),
    .out( s26 )
  );
  assign s32[0] = C_F;
  assign s32[1] = Z_F;
  assign s32[2] = s5[7];
  assign OP = IMM[7:4];
  assign s11 = IMM[3:0];
  assign s6 = s9[3:0];
  assign P1 = s9[5];
  assign Asel = s9[7:6];
  assign Ssel = s9[11:9];
  assign ALUop = s9[15:13];
  assign s23 = IMM[3:0];
  DemuxBus2 #(
    .Bits(8)
  )
  DemuxBus2_i21 (
    .sel( Asel ),
    .in( s5 ),
    .out_1( Rin ),
    .out_2( Min ),
    .out_3( s_out )
  );
  Decoder2 Decoder2_i22 (
    .sel( Asel ),
    .out_1( regw ),
    .out_2( memw ),
    .out_3( ENout )
  );
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i23 (
    .sel( P1 ),
    .in_0( s6 ),
    .in_1( OP ),
    .out( s7 )
  );
  assign hlt = (P1 & ~ (OP[0] | OP[1] | OP[2] | OP[3]) & IMM[0]);
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i24 (
    .sel( I_10 ),
    .in_0( IMM ),
    .in_1( Db ),
    .out( Yin )
  );
  assign \PC+1  = (~ (I_10 & s9[4]) & s9[8]);
  // ALU_Flag
  DIG_Register_BUS #(
    .Bits(3)
  )
  DIG_Register_BUS_i25 (
    .D( s32 ),
    .C( P1 ),
    .en( 1'b1 ),
    .Q( s33 )
  );
  assign s3 = Yin[7];
  assign s0 = Yin[6:0];
  assign C = s33[0];
  assign Z = s33[1];
  assign S = s33[2];
  assign s1 = (memw & ~ s3);
  // Drom
  DIG_ROM_128X8_Drom DIG_ROM_128X8_Drom_i26 (
    .A( s0 ),
    .sel( 1'b1 ),
    .D( s4 )
  );
  Mux_4x1 Mux_4x1_i27 (
    .sel( Rb ),
    .in_0( 1'b1 ),
    .in_1( C ),
    .in_2( Z ),
    .in_3( S ),
    .out( s31 )
  );
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i28 (
    .sel( s3 ),
    .in_0( s2 ),
    .in_1( s4 ),
    .out( Mout )
  );
  assign s14 = (s31 & s9[12]);
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i29 (
    .sel( s14 ),
    .in_0( s12 ),
    .in_1( IMM ),
    .out( s13 )
  );
endmodule
