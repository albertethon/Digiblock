/*
 * Generated by Digiblock. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule
module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule
module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule
module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule
module DIG_ROM_16X32_CSR_ROM (
    input [3:0] A,
    input sel,
    output reg [31:0] D
);
    reg [31:0] my_rom [0:-1];

    always @ (*) begin
        if (~sel)
            D = 32'hz;
        else if (A > 4'hffffffffffffffff)
            D = 32'h0;
        else
            D = my_rom[A];
    end

    initial begin
    end
endmodule
module PriorityEncoder3 (
    input in0,
    input in1,
    input in2,
    input in3,
    input in4,
    input in5,
    input in6,
    input in7,
    output reg [2:0] num,
    output any
);
    always @ (*) begin
        if (in7 == 1'b1)
            num = 3'h7;
        else if (in6 == 1'b1)
            num = 3'h6;
        else if (in5 == 1'b1)
            num = 3'h5;
        else if (in4 == 1'b1)
            num = 3'h4;
        else if (in3 == 1'b1)
            num = 3'h3;
        else if (in2 == 1'b1)
            num = 3'h2;
        else if (in1 == 1'b1)
            num = 3'h1;
        else 
            num = 3'h0;
    end

    assign any = in0 | in1 | in2 | in3 | in4 | in5 | in6 | in7;
endmodule
module DIG_BitExtenderSingle #(
    parameter outputBits = 2
)
(
    input in,
    output [(outputBits - 1):0] out
);
    assign out = {outputBits{in}};
endmodule
module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule
module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule
module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule
module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module CSR (
  input [31:0] aluR,
  input clk,
  input [11:0] csrAddr,
  input W_EN,
  input [31:0] pc_next,
  input EN,
  input mret,
  input ExInt,
  output [31:0] csrData,
  output INT,
  output [31:0] OUT,
  output [31:0] ISR,
  output [31:0] mepc
);
  wire [7:0] s0;
  wire s1;
  wire [3:0] s2;
  wire [7:0] s3;
  wire [3:0] s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire [2:0] s11;
  wire [31:0] s12;
  wire s13;
  wire [31:0] s14;
  wire INT_temp;
  wire [31:0] OUT_temp;
  wire [31:0] ISR_temp;
  wire [31:0] s15;
  wire s16;
  wire [31:0] mie;
  wire s17;
  wire [31:0] mstatus;
  wire s18;
  wire s19;
  wire [2:0] s20;
  wire [31:0] mtcmp;
  wire [31:0] mip;
  wire [31:0] mepc_temp;
  wire s21;
  wire T_int;
  wire E_int;
  wire s22;
  wire s23;
  wire s24;
  wire s25;
  wire s26;
  wire s27;
  wire [2:0] s28;
  // mtime
  DIG_Counter_Nbit #(
    .Bits(32)
  )
  DIG_Counter_Nbit_i0 (
    .en( EN ),
    .C( clk ),
    .clr( 1'b0 ),
    .out( s15 )
  );
  assign s27 = ~ clk;
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i1 (
    .Set( 1'b0 ),
    .D( ExInt ),
    .C( clk ),
    .Clr( mret ),
    .Q( s24 )
  );
  assign s2 = csrAddr[11:8];
  assign s0 = csrAddr[7:0];
  assign s3 = csrAddr[11:4];
  assign s4 = csrAddr[3:0];
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i2 (
    .a( s0 ),
    .b( 8'b100 ),
    .\= ( s1 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i3 (
    .a( s0 ),
    .b( 8'b0 ),
    .\= ( s5 )
  );
  // mepc
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i4 (
    .a( s0 ),
    .b( 8'b1000001 ),
    .\= ( s6 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i5 (
    .a( s0 ),
    .b( 8'b101 ),
    .\= ( s7 )
  );
  // CSR_ROM
  DIG_ROM_16X32_CSR_ROM DIG_ROM_16X32_CSR_ROM_i6 (
    .A( s4 ),
    .sel( 1'b1 ),
    .D( s12 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i7 (
    .a( s3 ),
    .b( 8'b11110001 ),
    .\= ( s13 )
  );
  // mip
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i8 (
    .a( s0 ),
    .b( 8'b1000100 ),
    .\= ( s10 )
  );
  CompUnsigned #(
    .Bits(4)
  )
  CompUnsigned_i9 (
    .a( s2 ),
    .b( 4'b11 ),
    .\= ( s19 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i10 (
    .a( s0 ),
    .b( 8'b110 ),
    .\= ( s9 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i11 (
    .a( s0 ),
    .b( 8'b110000 ),
    .\= ( s8 )
  );
  PriorityEncoder3 PriorityEncoder3_i12 (
    .in0( 1'b0 ),
    .in1( s8 ),
    .in2( s9 ),
    .in3( s7 ),
    .in4( s1 ),
    .in5( s5 ),
    .in6( s10 ),
    .in7( s6 ),
    .num( s11 )
  );
  assign s17 = (s19 & W_EN & s5);
  assign s16 = (s19 & W_EN & s1);
  assign s18 = (s19 & W_EN & s7);
  assign s21 = (s19 & W_EN & s9);
  assign s22 = (s19 & W_EN & s8);
  DIG_BitExtenderSingle #(
    .outputBits(3)
  )
  DIG_BitExtenderSingle_i13 (
    .in( s19 ),
    .out( s28 )
  );
  // mie
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i14 (
    .D( aluR ),
    .C( clk ),
    .en( s16 ),
    .Q( mie )
  );
  // mstatus
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i15 (
    .D( aluR ),
    .C( clk ),
    .en( s17 ),
    .Q( mstatus )
  );
  // mtvec
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i16 (
    .D( aluR ),
    .C( clk ),
    .en( s18 ),
    .Q( ISR_temp )
  );
  // mtimecmp
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i17 (
    .D( aluR ),
    .C( clk ),
    .en( s21 ),
    .Q( mtcmp )
  );
  // out
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i18 (
    .D( aluR ),
    .C( clk ),
    .en( s22 ),
    .Q( OUT_temp )
  );
  assign s20 = (s28 & s11);
  // TimeInt
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i19 (
    .a( mtcmp ),
    .b( s15 ),
    .\= ( T_int )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i20 (
    .Set( 1'b0 ),
    .D( T_int ),
    .C( clk ),
    .Clr( mret ),
    .Q( s23 )
  );
  assign mip[6:0] = 7'b0;
  assign mip[7] = s23;
  assign mip[10:8] = 3'b0;
  assign mip[11] = s24;
  assign mip[31:12] = 20'b0;
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i21 (
    .sel( s13 ),
    .in_0( s14 ),
    .in_1( s12 ),
    .out( csrData )
  );
  Mux_8x1_NBits #(
    .Bits(32)
  )
  Mux_8x1_NBits_i22 (
    .sel( s20 ),
    .in_0( 32'b0 ),
    .in_1( OUT_temp ),
    .in_2( mtcmp ),
    .in_3( ISR_temp ),
    .in_4( mie ),
    .in_5( mstatus ),
    .in_6( mip ),
    .in_7( mepc_temp ),
    .out( s14 )
  );
  assign INT_temp = (((T_int & mie[7]) | (E_int & mie[11])) & mstatus[3]);
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i23 (
    .Set( 1'b0 ),
    .D( 1'b1 ),
    .C( ExInt ),
    .Clr( s25 ),
    .Q( s26 )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i24 (
    .D( E_int ),
    .C( s27 ),
    .Q( s25 )
  );
  // mepc
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i25 (
    .D( pc_next ),
    .C( clk ),
    .en( INT_temp ),
    .Q( mepc_temp )
  );
  // ExtInt
  DIG_Register DIG_Register_i26 (
    .D( s26 ),
    .C( clk ),
    .en( EN ),
    .Q( E_int )
  );
  assign INT = INT_temp;
  assign OUT = OUT_temp;
  assign ISR = ISR_temp;
  assign mepc = mepc_temp;
endmodule
module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule

module preALU (
  input [3:0] alusel, // aluX input
  input [31:0] pc_alu,
  input [31:0] ins_alu, // instruction
  input [31:0] rs1,
  input [31:0] rs2,
  input [31:0] csrData,
  output [31:0] x,
  output [31:0] y
);
  wire [31:0] s0;
  wire [11:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  wire [31:0] s4;
  wire [31:0] s5;
  wire [31:0] s6;
  wire [19:0] s7;
  wire [31:0] s8;
  wire [19:0] s9;
  wire [31:0] s10;
  wire s11;
  wire s12;
  wire [31:0] s13;
  wire [31:0] s14;
  wire s15;
  wire [31:0] s16;
  wire [1:0] s17;
  wire [31:0] s18;
  wire s19;
  wire [31:0] s20;
  wire [1:0] s21;
  wire [31:0] s22;
  wire [1:0] s23;
  wire [1:0] s24;
  assign s0[4:0] = ins_alu[19:15];
  assign s0[31:5] = 27'b0;
  assign s1[11:5] = ins_alu[31:25];
  assign s1[4:0] = ins_alu[11:7];
  assign s2[4:0] = ins_alu[24:20];
  assign s2[31:5] = 27'b0;
  assign s3[31:12] = ins_alu[31:12];
  assign s3[11:0] = 12'b0;
  assign s4[4:0] = rs2[4:0];
  assign s4[31:5] = 27'b0;
  assign s5 = ~ rs1;
  assign s11 = ins_alu[31];
  assign s12 = alusel[0];
  assign s15 = alusel[1];
  assign s17 = alusel[1:0];
  assign s23 = alusel[3:2];
  assign s19 = alusel[1];
  assign s21 = alusel[1:0];
  assign s24 = alusel[3:2];
  assign s6 = ~ s0;
  DIG_BitExtenderSingle #(
    .outputBits(20)
  )
  DIG_BitExtenderSingle_i0 (
    .in( s11 ),
    .out( s7 )
  );
  DIG_BitExtenderSingle #(
    .outputBits(20)
  )
  DIG_BitExtenderSingle_i1 (
    .in( s11 ),
    .out( s9 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i2 (
    .sel( s12 ),
    .in_0( rs2 ),
    .in_1( s4 ),
    .out( s13 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i3 (
    .sel( s12 ),
    .in_0( s3 ),
    .in_1( 32'b100 ),
    .out( s14 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i4 (
    .sel( s19 ),
    .in_0( rs1 ),
    .in_1( pc_alu ),
    .out( s20 )
  );
  assign s8[11:0] = ins_alu[31:20];
  assign s8[31:12] = s7;
  assign s10[11:0] = s1;
  assign s10[31:12] = s9;
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i5 (
    .sel( s15 ),
    .in_0( s13 ),
    .in_1( s14 ),
    .out( s16 )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i6 (
    .sel( s21 ),
    .in_0( s0 ),
    .in_1( s6 ),
    .in_2( rs1 ),
    .in_3( s5 ),
    .out( s22 )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i7 (
    .sel( s17 ),
    .in_0( s8 ),
    .in_1( 32'b0 ),
    .in_2( s10 ),
    .in_3( s2 ),
    .out( s18 )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i8 (
    .sel( s24 ),
    .in_0( 32'b0 ),
    .in_1( s22 ),
    .in_2( rs1 ),
    .in_3( s20 ),
    .out( x )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i9 (
    .sel( s23 ),
    .in_0( 32'b0 ),
    .in_1( csrData ),
    .in_2( s18 ),
    .in_3( s16 ),
    .out( y )
  );
endmodule
module DIG_RAMDualPort
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
  input [(AddrBits-1):0] A,
  input [(Bits-1):0] Din,
  input str,
  input C,
  input ld,
  output [(Bits-1):0] D
);
  reg [(Bits-1):0] memory[0:((1 << AddrBits) - 1)];

  assign D = ld? memory[A] : 'hz;

  always @ (posedge C) begin
    if (str)
      memory[A] <= Din;
  end
endmodule
module DIG_RegisterFile
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input [(Bits-1):0] Din,
    input we,
    input [(AddrBits-1):0] Rw,
    input C,
    input [(AddrBits-1):0] Ra,
    input [(AddrBits-1):0] Rb,
    output [(Bits-1):0] Da,
    output [(Bits-1):0] Db
);

    reg [(Bits-1):0] memory[0:((1 << AddrBits)-1)];

    assign Da = memory[Ra];
    assign Db = memory[Rb];

    always @ (posedge C) begin
        if (we)
            memory[Rw] <= Din;
    end
endmodule

module preRW (
  input [2:0] sel,
  input [31:0] aluR,
  input [31:0] csrData,
  input [31:0] ramData,
  output [31:0] rwData
);
  wire s0;
  wire [23:0] s1;
  wire [23:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [1:0] s5;
  wire [31:0] s6;
  wire [31:0] s7;
  wire [31:0] s8;
  wire [31:0] s9;
  wire [7:0] s10;
  wire [15:0] s11;
  wire s12;
  wire s13;
  assign s10 = ramData[7:0];
  assign s11 = ramData[15:0];
  assign s8 = ramData[31:0];
  assign s0 = sel[2];
  assign s5 = sel[1:0];
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i0 (
    .sel( s0 ),
    .in_0( csrData ),
    .in_1( aluR ),
    .out( s9 )
  );
  assign s12 = s11[15];
  assign s13 = s10[7];
  DIG_BitExtenderSingle #(
    .outputBits(16)
  )
  DIG_BitExtenderSingle_i1 (
    .in( s12 ),
    .out( s3 )
  );
  DIG_BitExtenderSingle #(
    .outputBits(24)
  )
  DIG_BitExtenderSingle_i2 (
    .in( s13 ),
    .out( s1 )
  );
  Mux_2x1_NBits #(
    .Bits(24)
  )
  Mux_2x1_NBits_i3 (
    .sel( s0 ),
    .in_0( s1 ),
    .in_1( 24'b0 ),
    .out( s2 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i4 (
    .sel( s0 ),
    .in_0( s3 ),
    .in_1( 16'b0 ),
    .out( s4 )
  );
  assign s7[15:0] = s11;
  assign s7[31:16] = s4;
  assign s6[7:0] = s10;
  assign s6[31:8] = s2;
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i5 (
    .sel( s5 ),
    .in_0( s6 ),
    .in_1( s7 ),
    .in_2( s8 ),
    .in_3( s9 ),
    .out( rwData )
  );
endmodule

module HALT (
  input mw,
  input mr,
  input clk,
  output EN,
  output memw
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  assign s2 = ~ clk;
  assign s8 = (mr | mw);
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i0 (
    .Set( 1'b0 ),
    .D( s8 ),
    .C( s2 ),
    .Clr( 1'b0 ),
    .\~Q ( s6 )
  );
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i1 (
    .Set( 1'b0 ),
    .D( s0 ),
    .C( clk ),
    .Clr( 1'b0 ),
    .Q( s1 )
  );
  // delay1
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i2 (
    .Set( 1'b0 ),
    .D( s1 ),
    .C( s2 ),
    .Clr( 1'b0 ),
    .Q( s3 ),
    .\~Q ( s4 )
  );
  assign memw = (s5 & mw);
  assign EN = (s6 | s5);
  assign s0 = (s5 & mw);
  // delay2
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i3 (
    .Set( 1'b0 ),
    .D( s3 ),
    .C( s2 ),
    .Clr( 1'b0 ),
    .\~Q ( s7 )
  );
  assign s5 = (s4 & s7);
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule

module branch_PC (
  input [1:0] pcsel,
  input [31:0] ins_pc,
  input mret,
  input clk,
  input EN,
  input INT,
  input bxx,
  input [31:0] ISR,
  input [31:0] mepc,
  input [31:0] rs1,
  output [31:0] pc_next,
  output [31:0] pc
);
  wire [31:0] s0;
  wire [31:0] pc_temp;
  wire [31:0] pc_next_temp;
  wire s1;
  wire [12:0] s2;
  wire s3;
  wire [20:0] s4;
  wire [10:0] s5;
  wire [31:0] s6;
  wire [18:0] s7;
  wire [31:0] s8;
  wire [19:0] s9;
  wire [31:0] s10;
  wire s11;
  wire [31:0] s12;
  wire [31:0] s13;
  wire [31:0] s14;
  wire [31:0] s15;
  wire [31:0] s16;
  assign s1 = ins_pc[31];
  assign s3 = ins_pc[31];
  assign s11 = ins_pc[31];
  assign s2[0] = 1'b0;
  assign s2[4:1] = ins_pc[11:8];
  assign s2[10:5] = ins_pc[30:25];
  assign s2[11] = ins_pc[7];
  assign s2[12] = s1;
  assign s4[0] = 1'b0;
  assign s4[10:1] = ins_pc[30:21];
  assign s4[11] = ins_pc[20];
  assign s4[19:12] = ins_pc[19:12];
  assign s4[20] = s3;
  DIG_BitExtenderSingle #(
    .outputBits(20)
  )
  DIG_BitExtenderSingle_i0 (
    .in( s11 ),
    .out( s9 )
  );
  DIG_BitExtenderSingle #(
    .outputBits(11)
  )
  DIG_BitExtenderSingle_i1 (
    .in( s3 ),
    .out( s5 )
  );
  DIG_BitExtenderSingle #(
    .outputBits(19)
  )
  DIG_BitExtenderSingle_i2 (
    .in( s1 ),
    .out( s7 )
  );
  assign s6[20:0] = s4;
  assign s6[31:21] = s5;
  assign s8[12:0] = s2;
  assign s8[31:13] = s7;
  assign s10[11:0] = ins_pc[31:20];
  assign s10[31:12] = s9;
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i3 (
    .sel( bxx ),
    .in_0( 32'b100 ),
    .in_1( s8 ),
    .out( s12 )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i4 (
    .sel( pcsel ),
    .in_0( 32'b100 ),
    .in_1( s12 ),
    .in_2( s6 ),
    .in_3( s10 ),
    .out( s13 )
  );
  // pc
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i5 (
    .D( s0 ),
    .C( clk ),
    .en( EN ),
    .Q( pc_temp )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i6 (
    .sel( pcsel ),
    .in_0( pc_temp ),
    .in_1( pc_temp ),
    .in_2( pc_temp ),
    .in_3( rs1 ),
    .out( s14 )
  );
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i7 (
    .a( s14 ),
    .b( s13 ),
    .c_i( 1'b0 ),
    .s( s15 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i8 (
    .sel( INT ),
    .in_0( pc_next_temp ),
    .in_1( ISR ),
    .out( s16 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i9 (
    .sel( mret ),
    .in_0( s16 ),
    .in_1( mepc ),
    .out( s0 )
  );
  assign pc_next_temp[31:2] = s15[31:2];
  assign pc_next_temp[1:0] = 2'b0;
  assign pc_next = pc_next_temp;
  assign pc = pc_temp;
endmodule
module DIG_ROM_512X32_Irom (
    input [8:0] A,
    input sel,
    output reg [31:0] D
);
    reg [31:0] my_rom [0:17];

    always @ (*) begin
        if (~sel)
            D = 32'hz;
        else if (A > 9'h11)
            D = 32'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 32'h600513;
        my_rom[1] = 32'h42483;
        my_rom[2] = 32'h40992023;
        my_rom[3] = 32'h40992223;
        my_rom[4] = 32'h18000ef;
        my_rom[5] = 32'h440413;
        my_rom[6] = 32'h890913;
        my_rom[7] = 32'hfff50513;
        my_rom[8] = 32'hfe0512e3;
        my_rom[9] = 32'h100073;
        my_rom[10] = 32'h4c863;
        my_rom[11] = 32'h48a63;
        my_rom[12] = 32'h168693;
        my_rom[13] = 32'h80e7;
        my_rom[14] = 32'h158593;
        my_rom[15] = 32'h80e7;
        my_rom[16] = 32'h160613;
        my_rom[17] = 32'h80e7;
    end
endmodule
module Demux1
(
    output [0:0] out_0,
    output [0:0] out_1,
    input [0:0] sel,
    input [0:0] in
);
    assign out_0 = (sel == 1'h0)? in : 1'h0;
    assign out_1 = (sel == 1'h1)? in : 1'h0;
endmodule
module PriorityEncoder2 (
    input in0,
    input in1,
    input in2,
    input in3,
    output reg [1:0] num,
    output any
);
    always @ (*) begin
        if (in3 == 1'b1)
            num = 2'h3;
        else if (in2 == 1'b1)
            num = 2'h2;
        else if (in1 == 1'b1)
            num = 2'h1;
        else 
            num = 2'h0;
    end

    assign any = in0 | in1 | in2 | in3;
endmodule
module DIG_ROM_64X16_MROM (
    input [5:0] A,
    input sel,
    output reg [15:0] D
);
    reg [15:0] my_rom [0:61];

    always @ (*) begin
        if (~sel)
            D = 16'hz;
        else if (A > 6'h3d)
            D = 16'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 16'h7000;
        my_rom[1] = 16'hb069;
        my_rom[2] = 16'hb066;
        my_rom[3] = 16'hb077;
        my_rom[4] = 16'h0;
        my_rom[5] = 16'hb049;
        my_rom[6] = 16'hb046;
        my_rom[7] = 16'hb057;
        my_rom[8] = 16'h71ce;
        my_rom[9] = 16'h71cc;
        my_rom[10] = 16'h0;
        my_rom[11] = 16'h0;
        my_rom[12] = 16'h71c2;
        my_rom[13] = 16'h71ca;
        my_rom[14] = 16'h71c3;
        my_rom[15] = 16'h71cb;
        my_rom[16] = 16'h8080;
        my_rom[17] = 16'h9080;
        my_rom[18] = 16'ha080;
        my_rom[19] = 16'h0;
        my_rom[20] = 16'hc080;
        my_rom[21] = 16'hd080;
        my_rom[22] = 16'he080;
        my_rom[23] = 16'h0;
        my_rom[24] = 16'ha0;
        my_rom[25] = 16'h10a0;
        my_rom[26] = 16'h20a0;
        my_rom[27] = 16'h0;
        my_rom[28] = 16'hf0ef;
        my_rom[29] = 16'hf0e0;
        my_rom[30] = 16'hf2f0;
        my_rom[31] = 16'hf3f0;
        my_rom[32] = 16'hf0c0;
        my_rom[33] = 16'hf0d1;
        my_rom[34] = 16'hf0c2;
        my_rom[35] = 16'hf0c3;
        my_rom[36] = 16'hf0c4;
        my_rom[37] = 16'hf0d5;
        my_rom[38] = 16'hf0c6;
        my_rom[39] = 16'hf0c7;
        my_rom[40] = 16'hf0c8;
        my_rom[41] = 16'h0;
        my_rom[42] = 16'h0;
        my_rom[43] = 16'h0;
        my_rom[44] = 16'h0;
        my_rom[45] = 16'hf0dd;
        my_rom[46] = 16'h0;
        my_rom[47] = 16'h0;
        my_rom[48] = 16'hf080;
        my_rom[49] = 16'hf0b1;
        my_rom[50] = 16'hf082;
        my_rom[51] = 16'hf083;
        my_rom[52] = 16'hf084;
        my_rom[53] = 16'hf085;
        my_rom[54] = 16'hf086;
        my_rom[55] = 16'hf087;
        my_rom[56] = 16'h0;
        my_rom[57] = 16'h0;
        my_rom[58] = 16'h0;
        my_rom[59] = 16'h0;
        my_rom[60] = 16'h0;
        my_rom[61] = 16'hf0bd;
    end
endmodule

module microp_controller (
  input [31:0] ins,
  output [1:0] pcsel,
  output [3:0] aluop,
  output [3:0] alusel,
  output [2:0] wsel,
  output rw,
  output brk,
  output csrw,
  output mw,
  output mr,
  output mret
);
  wire [5:0] s0;
  wire [15:0] s1;
  wire [2:0] funct3;
  wire [2:0] s2;
  wire [5:0] s3;
  wire [4:0] op;
  wire [4:0] rd;
  wire break;
  wire branch;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire s16;
  wire s17;
  wire s18;
  wire s19;
  wire RV32;
  wire s20;
  wire s21;
  wire [5:0] s22;
  wire [1:0] s23;
  wire s24;
  wire s25;
  wire s26;
  wire [3:0] s27;
  assign RV32 = (ins[0] & ins[1]);
  assign op = ins[6:2];
  assign rd = ins[11:7];
  assign funct3 = ins[14:12];
  assign break = ins[20];
  assign branch = ins[30];
  // alux
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i0 (
    .a( op ),
    .b( 5'b1100 ),
    .\= ( s4 )
  );
  // aluix
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i1 (
    .a( op ),
    .b( 5'b100 ),
    .\= ( s5 )
  );
  // jal
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i2 (
    .a( op ),
    .b( 5'b11011 ),
    .\= ( s6 )
  );
  // jalr
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i3 (
    .a( op ),
    .b( 5'b11001 ),
    .\= ( s7 )
  );
  // auipc
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i4 (
    .a( op ),
    .b( 5'b101 ),
    .\= ( s8 )
  );
  // lx
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i5 (
    .a( op ),
    .b( 5'b0 ),
    .\= ( s9 )
  );
  // csrx
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i6 (
    .a( op ),
    .b( 5'b11100 ),
    .\= ( s10 )
  );
  // lui
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i7 (
    .a( op ),
    .b( 5'b1101 ),
    .\= ( s11 )
  );
  CompUnsigned #(
    .Bits(3)
  )
  CompUnsigned_i8 (
    .a( funct3 ),
    .b( 3'b0 ),
    .\= ( s21 )
  );
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i9 (
    .a( rd ),
    .b( 5'b0 ),
    .\= ( s24 )
  );
  // sx
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i10 (
    .a( op ),
    .b( 5'b1000 ),
    .\= ( s13 )
  );
  // bxx
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i11 (
    .a( op ),
    .b( 5'b11000 ),
    .\= ( s12 )
  );
  CompUnsigned #(
    .Bits(3)
  )
  CompUnsigned_i12 (
    .a( funct3 ),
    .b( 3'b101 ),
    .\= ( s26 )
  );
  Demux1 Demux1_i13 (
    .sel( branch ),
    .in( s4 ),
    .out_0( s14 ),
    .out_1( s15 )
  );
  assign s20 = (s10 & RV32);
  // single
  PriorityEncoder2 PriorityEncoder2_i14 (
    .in0( s11 ),
    .in1( s8 ),
    .in2( s6 ),
    .in3( s7 ),
    .num( s23 ),
    .any( s25 )
  );
  assign s19 = (s26 & branch);
  assign mw = (RV32 & s13);
  assign mr = (s9 & RV32);
  Demux1 Demux1_i15 (
    .sel( s19 ),
    .in( s5 ),
    .out_0( s16 ),
    .out_1( s17 )
  );
  DIG_BitExtenderSingle #(
    .outputBits(4)
  )
  DIG_BitExtenderSingle_i16 (
    .in( s25 ),
    .out( s27 )
  );
  assign csrw = (~ s21 & s20);
  assign brk = (break & s20 & s21);
  assign mret = (~ break & s21 & s20);
  // multi
  PriorityEncoder3 PriorityEncoder3_i17 (
    .in0( s10 ),
    .in1( s12 ),
    .in2( s9 ),
    .in3( s13 ),
    .in4( s14 ),
    .in5( s15 ),
    .in6( s16 ),
    .in7( s17 ),
    .num( s2 ),
    .any( s18 )
  );
  assign s22[1:0] = s23;
  assign s22[5:2] = (s27 & 4'b111);
  assign s3[2:0] = funct3;
  assign s3[5:3] = s2;
  Mux_2x1_NBits #(
    .Bits(6)
  )
  Mux_2x1_NBits_i18 (
    .sel( s18 ),
    .in_0( s22 ),
    .in_1( s3 ),
    .out( s0 )
  );
  // MROM
  DIG_ROM_64X16_MROM DIG_ROM_64X16_MROM_i19 (
    .A( s0 ),
    .sel( 1'b1 ),
    .D( s1 )
  );
  assign rw = (s1[15] & ~ s24 & RV32);
  assign aluop = s1[3:0];
  assign alusel = s1[7:4];
  assign pcsel = s1[9:8];
  assign wsel = s1[14:12];
endmodule
module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule
module CompSigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = $signed(a) > $signed(b);
    assign \= = $signed(a) == $signed(b);
    assign \< = $signed(a) < $signed(b);
endmodule
module LogicalLeft #(
parameter Bits = 4,
parameter shiftBits=3
)
(
    input [(Bits-1):0] in,
    input [(shiftBits-1):0] shift,
    output [(Bits - 1):0] out
);

assign out = (in << shift);

endmodule
module LogicalRight #(
parameter Bits = 4,
parameter shiftBits=3
)
(
    input [(Bits-1):0] in,
    input [(shiftBits-1):0] shift,
    output [(Bits - 1):0] out
);

assign out = (in >> shift);

endmodule
module ArithmeticRight #(
parameter Bits = 4,
parameter shiftBits=3
)
(
    input [(Bits-1):0] in,
    input [(shiftBits-1):0] shift,
    output [(Bits - 1):0] out
);

assign out=($signed(in)>>>shift);

endmodule
module Mux_16x1_NBits #(
    parameter Bits = 2
)
(
    input [3:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    input [(Bits - 1):0] in_8,
    input [(Bits - 1):0] in_9,
    input [(Bits - 1):0] in_10,
    input [(Bits - 1):0] in_11,
    input [(Bits - 1):0] in_12,
    input [(Bits - 1):0] in_13,
    input [(Bits - 1):0] in_14,
    input [(Bits - 1):0] in_15,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            4'h0: out = in_0;
            4'h1: out = in_1;
            4'h2: out = in_2;
            4'h3: out = in_3;
            4'h4: out = in_4;
            4'h5: out = in_5;
            4'h6: out = in_6;
            4'h7: out = in_7;
            4'h8: out = in_8;
            4'h9: out = in_9;
            4'ha: out = in_10;
            4'hb: out = in_11;
            4'hc: out = in_12;
            4'hd: out = in_13;
            4'he: out = in_14;
            4'hf: out = in_15;
            default:
                out = 'h0;
        endcase
    end
endmodule

module ALU (
  input [3:0] aluop,
  input [31:0] x,
  input [31:0] y,
  output [31:0] aluR
);
  wire [31:0] addx;
  wire [31:0] sub;
  wire [31:0] andx;
  wire [31:0] orx;
  wire [31:0] xorx;
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire [5:0] s6;
  wire [31:0] bge;
  wire [31:0] bgeu;
  wire [31:0] bne;
  wire [31:0] \sltx&blt ;
  wire [31:0] beq;
  wire [31:0] \sltxu&bltu ;
  wire [31:0] sllx;
  wire [31:0] srlx;
  wire [31:0] srax;
  // +
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i0 (
    .a( x ),
    .b( y ),
    .c_i( 1'b0 ),
    .s( addx )
  );
  // -
  DIG_Sub #(
    .Bits(32)
  )
  DIG_Sub_i1 (
    .a( x ),
    .b( y ),
    .c_i( 1'b0 ),
    .s( sub )
  );
  assign andx = (x & y);
  assign orx = (x | y);
  assign xorx = (x ^ y);
  // s>=<
  CompSigned #(
    .Bits(32)
  )
  CompSigned_i2 (
    .a( x ),
    .b( y ),
    .\> ( s0 ),
    .\= ( s1 ),
    .\< ( s2 )
  );
  // >=<
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i3 (
    .a( x ),
    .b( y ),
    .\> ( s3 ),
    .\= ( s4 ),
    .\< ( s5 )
  );
  assign s6 = y[5:0];
  assign bge[0] = (s0 | s1);
  assign bge[31:1] = 31'b0;
  assign bgeu[0] = (s3 | s4);
  assign bgeu[31:1] = 31'b0;
  assign bne[0] = ~ s4;
  assign bne[31:1] = 31'b0;
  assign \sltx&blt [0] = s2;
  assign \sltx&blt [31:1] = 31'b0;
  assign beq[0] = s1;
  assign beq[31:1] = 31'b0;
  assign \sltxu&bltu [0] = s5;
  assign \sltxu&bltu [31:1] = 31'b0;
  // LeftL
  LogicalLeft #(
    .Bits(32),
    .shiftBits(6)
  )
  LogicalLeft_i4 (
    .in( x ),
    .shift( s6 ),
    .out( sllx )
  );
  // RightL
  LogicalRight #(
    .Bits(32),
    .shiftBits(6)
  )
  LogicalRight_i5 (
    .in( x ),
    .shift( s6 ),
    .out( srlx )
  );
  // RightA
  ArithmeticRight #(
    .Bits(32),
    .shiftBits(6)
  )
  ArithmeticRight_i6 (
    .in( x ),
    .shift( s6 ),
    .out( srax )
  );
  Mux_16x1_NBits #(
    .Bits(32)
  )
  Mux_16x1_NBits_i7 (
    .sel( aluop ),
    .in_0( addx ),
    .in_1( sllx ),
    .in_2( \sltx&blt  ),
    .in_3( \sltxu&bltu  ),
    .in_4( xorx ),
    .in_5( srlx ),
    .in_6( orx ),
    .in_7( andx ),
    .in_8( sub ),
    .in_9( x ),
    .in_10( bge ),
    .in_11( bgeu ),
    .in_12( bne ),
    .in_13( srax ),
    .in_14( beq ),
    .in_15( y ),
    .out( aluR )
  );
endmodule

module preMW (
  input [31:0] rs2,
  input [2:0] sel,
  output [31:0] mwData
);
  wire [1:0] s0;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  assign s2[15:0] = rs2[15:0];
  assign s2[31:16] = 16'b0;
  assign s3[7:0] = rs2[7:0];
  assign s3[31:8] = 24'b0;
  assign s0 = sel[1:0];
  assign s1 = rs2[31:0];
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i0 (
    .sel( s0 ),
    .in_0( s3 ),
    .in_1( s2 ),
    .in_2( s1 ),
    .in_3( 32'b0 ),
    .out( mwData )
  );
endmodule
module DIG_ROM_256X32_Drom (
    input [7:0] A,
    input sel,
    output reg [31:0] D
);
    reg [31:0] my_rom [0:44];

    always @ (*) begin
        if (~sel)
            D = 32'hz;
        else if (A > 8'h2c)
            D = 32'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 32'h0;
        my_rom[1] = 32'hfffff0b7;
        my_rom[2] = 32'h400093;
        my_rom[3] = 32'h40016f;
        my_rom[4] = 32'h158513;
        my_rom[5] = 32'hfeb50fe3;
        my_rom[6] = 32'hfff20193;
        my_rom[7] = 32'h318233;
        my_rom[8] = 32'h308023;
        my_rom[9] = 32'h309023;
        my_rom[10] = 32'h30a023;
        my_rom[11] = 32'h40a223;
        my_rom[12] = 32'h402383;
        my_rom[13] = 32'h800403;
        my_rom[14] = 32'h801403;
        my_rom[15] = 32'h804403;
        my_rom[16] = 32'h805403;
        my_rom[17] = 32'h802403;
        my_rom[18] = 32'hff3a413;
        my_rom[19] = 32'hffe3b413;
        my_rom[20] = 32'hfff44413;
        my_rom[21] = 32'h247493;
        my_rom[22] = 32'h249513;
        my_rom[23] = 32'h1f4d593;
        my_rom[24] = 32'h25d593;
        my_rom[25] = 32'h40125613;
        my_rom[26] = 32'h40460633;
        my_rom[27] = 32'hc616b3;
        my_rom[28] = 32'hc42733;
        my_rom[29] = 32'hc43733;
        my_rom[30] = 32'h864733;
        my_rom[31] = 32'he6d7b3;
        my_rom[32] = 32'h40f75733;
        my_rom[33] = 32'hd77733;
        my_rom[34] = 32'hc76833;
        my_rom[35] = 32'h200713;
        my_rom[36] = 32'h11d873;
        my_rom[37] = 32'h11d873;
        my_rom[38] = 32'h810f3;
        my_rom[39] = 32'h710f3;
        my_rom[40] = 32'ha973;
        my_rom[41] = 32'h25973;
        my_rom[42] = 32'h1039f3;
        my_rom[43] = 32'h10f9f3;
        my_rom[44] = 32'he7;
    end
endmodule

module \microp-CPU  (
  input clock,
  input hand,
  input manual,
  input reset,
  input key,
  output [31:0] OUT
);
  wire [3:0] s0;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  wire [3:0] s4;
  wire [31:0] s5;
  wire [31:0] s6;
  wire [31:0] s7;
  wire [31:0] s8;
  wire [31:0] s9;
  wire [8:0] s10;
  wire [7:0] s11;
  wire [31:0] s12;
  wire s13;
  wire clk;
  wire [31:0] s14;
  wire s15;
  wire [31:0] s16;
  wire regw;
  wire [4:0] s17;
  wire [4:0] s18;
  wire [4:0] s19;
  wire [11:0] s20;
  wire [1:0] s21;
  wire [2:0] s22;
  wire brk;
  wire csrw;
  wire mw;
  wire mr;
  wire mret;
  wire s23;
  wire [31:0] s24;
  wire [31:0] s25;
  wire EN;
  wire memw;
  wire s26;
  wire s27;
  wire s28;
  wire int;
  wire [31:0] s29;
  wire [31:0] s30;
  wire [31:0] s31;
  Mux_2x1 Mux_2x1_i0 (
    .sel( manual ),
    .in_0( hand ),
    .in_1( clock ),
    .out( s26 )
  );
  assign clk = (s26 | s28);
  assign s27 = (int & s26 & reset);
  CSR CSR_i1 (
    .aluR( s3 ),
    .clk( clk ),
    .csrAddr( s20 ),
    .W_EN( csrw ),
    .pc_next( s31 ),
    .EN( EN ),
    .mret( mret ),
    .ExInt( key ),
    .csrData( s9 ),
    .INT( int ),
    .OUT( OUT ),
    .ISR( s29 ),
    .mepc( s30 )
  );
  preALU preALU_i2 (
    .alusel( s4 ),
    .pc_alu( s5 ),
    .ins_alu( s6 ),
    .rs1( s7 ),
    .rs2( s8 ),
    .csrData( s9 ),
    .x( s1 ),
    .y( s2 )
  );
  // Dram
  DIG_RAMDualPort #(
    .Bits(32),
    .AddrBits(8)
  )
  DIG_RAMDualPort_i3 (
    .A( s11 ),
    .Din( s12 ),
    .str( s13 ),
    .C( clk ),
    .ld( 1'b1 ),
    .D( s14 )
  );
  // regs
  DIG_RegisterFile #(
    .Bits(32),
    .AddrBits(5)
  )
  DIG_RegisterFile_i4 (
    .Din( s16 ),
    .we( regw ),
    .Rw( s17 ),
    .C( clk ),
    .Ra( s18 ),
    .Rb( s19 ),
    .Da( s7 ),
    .Db( s8 )
  );
  preRW preRW_i5 (
    .sel( s22 ),
    .aluR( s3 ),
    .csrData( s9 ),
    .ramData( s25 ),
    .rwData( s16 )
  );
  HALT HALT_i6 (
    .mw( mw ),
    .mr( mr ),
    .clk( clk ),
    .EN( EN ),
    .memw( memw )
  );
  // break
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i7 (
    .Set( 1'b0 ),
    .D( 1'b1 ),
    .C( brk ),
    .Clr( s27 ),
    .Q( s28 )
  );
  branch_PC branch_PC_i8 (
    .pcsel( s21 ),
    .ins_pc( s6 ),
    .mret( mret ),
    .clk( clk ),
    .EN( EN ),
    .INT( int ),
    .bxx( s23 ),
    .ISR( s29 ),
    .mepc( s30 ),
    .rs1( s7 ),
    .pc_next( s31 ),
    .pc( s5 )
  );
  assign s10 = s5[10:2];
  // Irom
  DIG_ROM_512X32_Irom DIG_ROM_512X32_Irom_i9 (
    .A( s10 ),
    .sel( 1'b1 ),
    .D( s6 )
  );
  microp_controller microp_controller_i10 (
    .ins( s6 ),
    .pcsel( s21 ),
    .aluop( s0 ),
    .alusel( s4 ),
    .wsel( s22 ),
    .rw( regw ),
    .brk( brk ),
    .csrw( csrw ),
    .mw( mw ),
    .mr( mr ),
    .mret( mret )
  );
  assign s17 = s6[11:7];
  assign s18 = s6[19:15];
  assign s19 = s6[24:20];
  assign s20 = s6[31:20];
  ALU ALU_i11 (
    .aluop( s0 ),
    .x( s1 ),
    .y( s2 ),
    .aluR( s3 )
  );
  preMW preMW_i12 (
    .rs2( s8 ),
    .sel( s22 ),
    .mwData( s12 )
  );
  assign s15 = s3[10];
  assign s11 = s3[9:2];
  assign s23 = s3[0];
  // Drom
  DIG_ROM_256X32_Drom DIG_ROM_256X32_Drom_i13 (
    .A( s11 ),
    .sel( 1'b1 ),
    .D( s24 )
  );
  assign s13 = (memw & s15);
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i14 (
    .sel( s15 ),
    .in_0( s24 ),
    .in_1( s14 ),
    .out( s25 )
  );
endmodule
