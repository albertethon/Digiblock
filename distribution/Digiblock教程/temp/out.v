/*
 * Generated by Digiblock. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule
module DIG_ROM_16X32_CSR_ROM (
    input [3:0] A,
    input sel,
    output reg [31:0] D
);
    reg [31:0] my_rom [0:-1];

    always @ (*) begin
        if (~sel)
            D = 32'hz;
        else if (A > 4'hf)
            D = 32'h0;
        else
            D = my_rom[A];
    end

    initial begin
    end
endmodule
module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module PriorityEncoder3 (
    input in0,
    input in1,
    input in2,
    input in3,
    input in4,
    input in5,
    input in6,
    input in7,
    output reg [2:0] num,
    output any
);
    always @ (*) begin
        if (in7 == 1'b1)
            num = 3'h7;
        else if (in6 == 1'b1)
            num = 3'h6;
        else if (in5 == 1'b1)
            num = 3'h5;
        else if (in4 == 1'b1)
            num = 3'h4;
        else if (in3 == 1'b1)
            num = 3'h3;
        else if (in2 == 1'b1)
            num = 3'h2;
        else if (in1 == 1'b1)
            num = 3'h1;
        else 
            num = 3'h0;
    end

    assign any = in0 | in1 | in2 | in3 | in4 | in5 | in6 | in7;
endmodule
module DIG_RAMDualAccess
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input C, // Clock signal
    input ld,
    input [(AddrBits-1):0] \1A ,
    input [(AddrBits-1):0] \2A ,
    input [(Bits-1):0] \1Din ,
    input str,
    output [(Bits-1):0] \1D ,
    output [(Bits-1):0] \2D
);
    // CAUTION: uses distributed RAM
    reg [(Bits-1):0] memory [0:((1 << AddrBits)-1)];

    assign \1D = ld? memory[\1A ] : 'hz;
    assign \2D = memory[\2A ];

    always @ (posedge C) begin
        if (str)
            memory[\1A ] <= \1Din ;
    end

endmodule
module DIG_BitExtenderSingle #(
    parameter outputBits = 2
)
(
    input in,
    output [(outputBits - 1):0] out
);
    assign out = {outputBits{in}};
endmodule
module DIG_CounterPreset_mtime #(
    parameter Bits = 2,
    parameter maxValue = 4
)
(
    input C,
    input en,
    input clr,
    input dir,
    input [(Bits-1):0] in,
    input ld,
    output [(Bits-1):0] out,
    output ovf
);

    reg [(Bits-1):0] count = 'h0;

    function [(Bits-1):0] maxVal (input [(Bits-1):0] maxv);
        if (maxv == 0)
            maxVal = (1 << Bits) - 1;
        else
            maxVal = maxv;
    endfunction

    assign out = count;
    assign ovf = ((count == maxVal(maxValue) & dir == 1'b0)
                  | (count == 'b0 & dir == 1'b1))? en : 1'b0;

    always @ (posedge C) begin
        if (clr == 1'b1)
            count <= 'h0;
        else if (ld == 1'b1)
            count <= in;
        else if (en == 1'b1) begin
            if (dir == 1'b0) begin
                if (count == maxVal(maxValue))
                    count <= 'h0;
                else
                    count <= count + 1'b1;
            end
            else begin
                if (count == 'h0)
                    count <= maxVal(maxValue);
                else
                    count <= count - 1;
            end
        end
    end
endmodule
module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule
module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule
module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_D_FF_AS_1bit
#(
    parameter Default = 0
)
(
   input Set,
   input D,
   input C,
   input Clr,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q  = ~state;

    always @ (posedge C or posedge Clr or posedge Set)
    begin
        if (Set)
            state <= 1'b1;
        else if (Clr)
            state <= 'h0;
        else
            state <= D;
    end

    initial begin
        state = Default;
    end
endmodule
module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule

module CSR (
  input [31:0] ins_ID,
  input [31:0] aluR,
  input [31:0] mepc,
  input [11:0] Wa,
  input clk,
  input W_EN,
  input EN,
  input ExInt,
  output [31:0] ISR,
  output [31:0] CSR,
  output INT,
  output [31:0] OUT,
  output mret,
  output [31:0] test_1,
  output [31:0] test_2
);
  wire [7:0] s0;
  wire s1;
  wire [3:0] s2;
  wire s3;
  wire s4;
  wire [31:0] ISR_temp;
  wire INT_temp;
  wire s5;
  wire [31:0] mie;
  wire s6;
  wire [31:0] mstatus;
  wire s7;
  wire s8;
  wire s9;
  wire [31:0] test_2_temp;
  wire s10;
  wire MTIE;
  wire s11;
  wire [31:0] OUT_temp;
  wire s12;
  wire [7:0] s13;
  wire s14;
  wire [11:0] Raddr;
  wire [3:0] s15;
  wire [7:0] s16;
  wire [3:0] s17;
  wire s18;
  wire s19;
  wire s20;
  wire s21;
  wire s22;
  wire s23;
  wire s24;
  wire [2:0] s25;
  wire s26;
  wire [31:0] mip;
  wire [31:0] s27;
  wire [31:0] s28;
  wire s29;
  wire [31:0] s30;
  wire mret_temp;
  wire s31;
  wire s32;
  wire E_int;
  wire T_int;
  wire s33;
  wire [3:0] s34;
  wire s35;
  wire [31:0] s36;
  wire s37;
  wire [31:0] s38;
  wire s39;
  wire [7:0] s40;
  wire s41;
  wire [31:0] s42;
  wire [31:0] test_1_temp;
  wire s43;
  wire s44;
  wire s45;
  wire s46;
  wire s47;
  wire s48;
  wire s49;
  wire s50;
  assign mret_temp = ((ins_ID[0] & ins_ID[1] & ins_ID[4] & ins_ID[5] & ins_ID[6]) & ~ (ins_ID[2] | ins_ID[3] | ins_ID[12] | ins_ID[13] | ins_ID[14]) & ~ ins_ID[20]);
  assign s50 = ~ clk;
  assign s2 = Wa[11:8];
  assign s0 = Wa[7:0];
  assign s34 = Wa[3:0];
  assign s40 = Wa[11:4];
  assign Raddr = ins_ID[31:20];
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i0 (
    .a( s0 ),
    .b( 8'b100 ),
    .\= ( s1 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i1 (
    .a( s0 ),
    .b( 8'b0 ),
    .\= ( s3 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i2 (
    .a( s0 ),
    .b( 8'b101 ),
    .\= ( s4 )
  );
  CompUnsigned #(
    .Bits(4)
  )
  CompUnsigned_i3 (
    .a( s2 ),
    .b( 4'b11 ),
    .\= ( s8 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i4 (
    .a( s0 ),
    .b( 8'b110 ),
    .\= ( s10 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i5 (
    .a( s0 ),
    .b( 8'b110000 ),
    .\= ( s12 )
  );
  CompUnsigned #(
    .Bits(12)
  )
  CompUnsigned_i6 (
    .a( Wa ),
    .b( Raddr ),
    .\= ( s29 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i7 (
    .a( s40 ),
    .b( 8'b110101 ),
    .\= ( s41 )
  );
  assign s15 = Raddr[11:8];
  assign s13 = Raddr[7:0];
  assign s16 = Raddr[11:4];
  assign s17 = Raddr[3:0];
  assign s6 = (s8 & W_EN & s3);
  assign s5 = (s8 & W_EN & s1);
  assign s7 = (s8 & W_EN & s4);
  assign s9 = (s8 & W_EN & s10);
  assign s11 = (s8 & W_EN & s12);
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i8 (
    .a( s13 ),
    .b( 8'b100 ),
    .\= ( s14 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i9 (
    .a( s13 ),
    .b( 8'b0 ),
    .\= ( s18 )
  );
  // mepc
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i10 (
    .a( s13 ),
    .b( 8'b1000001 ),
    .\= ( s19 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i11 (
    .a( s13 ),
    .b( 8'b101 ),
    .\= ( s20 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i12 (
    .a( s16 ),
    .b( 8'b110101 ),
    .\= ( s24 )
  );
  // mip
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i13 (
    .a( s13 ),
    .b( 8'b1000100 ),
    .\= ( s23 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i14 (
    .a( s13 ),
    .b( 8'b110 ),
    .\= ( s22 )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i15 (
    .a( s16 ),
    .b( 8'b11110001 ),
    .\= ( s35 )
  );
  // CSR_ROM
  DIG_ROM_16X32_CSR_ROM DIG_ROM_16X32_CSR_ROM_i16 (
    .A( s17 ),
    .sel( 1'b1 ),
    .D( s36 )
  );
  CompUnsigned #(
    .Bits(4)
  )
  CompUnsigned_i17 (
    .a( s15 ),
    .b( 4'b11 ),
    .\= ( s37 )
  );
  assign s33 = (s41 & W_EN);
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i18 (
    .a( s13 ),
    .b( 8'b110000 ),
    .\= ( s21 )
  );
  // mie
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i19 (
    .D( aluR ),
    .C( clk ),
    .en( s5 ),
    .Q( mie )
  );
  // mstatus
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i20 (
    .D( aluR ),
    .C( clk ),
    .en( s6 ),
    .Q( mstatus )
  );
  // mtvec
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i21 (
    .D( aluR ),
    .C( clk ),
    .en( s7 ),
    .Q( ISR_temp )
  );
  // mtimecmp
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i22 (
    .D( aluR ),
    .C( clk ),
    .en( s9 ),
    .Q( test_2_temp )
  );
  // out
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i23 (
    .D( aluR ),
    .C( clk ),
    .en( s11 ),
    .Q( OUT_temp )
  );
  PriorityEncoder3 PriorityEncoder3_i24 (
    .in0( s21 ),
    .in1( s22 ),
    .in2( s20 ),
    .in3( s14 ),
    .in4( s18 ),
    .in5( s23 ),
    .in6( s19 ),
    .in7( s24 ),
    .num( s25 ),
    .any( s26 )
  );
  // CSR_RAM
  DIG_RAMDualAccess #(
    .Bits(32),
    .AddrBits(4)
  )
  DIG_RAMDualAccess_i25 (
    .str( s33 ),
    .C( clk ),
    .ld( 1'b1 ),
    .\1A ( s34 ),
    .\1Din ( aluR ),
    .\2A ( s17 ),
    .\2D ( s27 )
  );
  assign s39 = (s37 & s26);
  assign MTIE = mie[7];
  DIG_BitExtenderSingle #(
    .outputBits(32)
  )
  DIG_BitExtenderSingle_i26 (
    .in( s39 ),
    .out( s42 )
  );
  // mtime
  DIG_CounterPreset_mtime #(
    .Bits(32),
    .maxValue(0)
  )
  DIG_CounterPreset_mtime_i27 (
    .en( EN ),
    .C( clk ),
    .dir( 1'b0 ),
    .in( 32'b0 ),
    .ld( 1'b0 ),
    .clr( MTIE ),
    .out( test_1_temp )
  );
  assign s49 = ~ MTIE;
  // TimeInt
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i28 (
    .a( test_1_temp ),
    .b( test_2_temp ),
    .\= ( s43 )
  );
  assign T_int = (s43 & MTIE);
  Mux_8x1_NBits #(
    .Bits(32)
  )
  Mux_8x1_NBits_i29 (
    .sel( s25 ),
    .in_0( OUT_temp ),
    .in_1( test_2_temp ),
    .in_2( ISR_temp ),
    .in_3( mie ),
    .in_4( mstatus ),
    .in_5( mip ),
    .in_6( mepc ),
    .in_7( s27 ),
    .out( s28 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i30 (
    .sel( s29 ),
    .in_0( s30 ),
    .in_1( aluR ),
    .out( CSR )
  );
  DIG_Register DIG_Register_i31 (
    .D( E_int ),
    .C( clk ),
    .en( INT_temp ),
    .Q( s32 )
  );
  DIG_Register DIG_Register_i32 (
    .D( T_int ),
    .C( clk ),
    .en( INT_temp ),
    .Q( s31 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i33 (
    .sel( s35 ),
    .in_0( s38 ),
    .in_1( s36 ),
    .out( s30 )
  );
  assign s38 = (s42 & s28);
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i34 (
    .Set( 1'b0 ),
    .D( 1'b1 ),
    .C( ExInt ),
    .Clr( s44 ),
    .Q( s45 )
  );
  assign s44 = (~ mie[11] | s46);
  DIG_Register DIG_Register_i35 (
    .D( s45 ),
    .C( clk ),
    .en( EN ),
    .Q( E_int )
  );
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i36 (
    .D( E_int ),
    .C( clk ),
    .Q( s46 )
  );
  assign INT_temp = ((E_int | T_int) & mstatus[3] & s47);
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i37 (
    .Set( s48 ),
    .D( 1'b0 ),
    .C( 1'b0 ),
    .Clr( mret_temp ),
    .\~Q ( s47 )
  );
  DIG_Register DIG_Register_i38 (
    .D( INT_temp ),
    .C( clk ),
    .en( EN ),
    .Q( s48 )
  );
  assign mip[6:0] = 7'b0;
  assign mip[7] = s31;
  assign mip[10:8] = 3'b0;
  assign mip[11] = s32;
  assign mip[31:12] = 20'b0;
  assign ISR = ISR_temp;
  assign INT = INT_temp;
  assign OUT = OUT_temp;
  assign mret = mret_temp;
  assign test_1 = test_1_temp;
  assign test_2 = test_2_temp;
endmodule

module ID_EX (
  input clr,
  input [31:0] PC_ID,
  input [31:0] ins_ID,
  input clk,
  input EN,
  input [31:0] RS1_ID,
  input [31:0] RS2_ID,
  input Flag_ID,
  input [31:0] CSR_ID,
  input [31:0] MEM_ID,
  input [31:0] Addr_ID,
  output [31:0] PC_EX,
  output [31:0] ins_EX,
  output [31:0] RS1_EX,
  output [31:0] RS2_EX,
  output [31:0] CSR_EX,
  output [31:0] MEM_EX,
  output [31:0] Addr_EX,
  output Flag_EX
);
  wire [31:0] s0;
  // PC
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i0 (
    .D( PC_ID ),
    .C( clk ),
    .en( EN ),
    .Q( PC_EX )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i1 (
    .sel( clr ),
    .in_0( ins_ID ),
    .in_1( 32'b0 ),
    .out( s0 )
  );
  // RS1
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i2 (
    .D( RS1_ID ),
    .C( clk ),
    .en( EN ),
    .Q( RS1_EX )
  );
  // RS2
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i3 (
    .D( RS2_ID ),
    .C( clk ),
    .en( EN ),
    .Q( RS2_EX )
  );
  // MEM
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i4 (
    .D( MEM_ID ),
    .C( clk ),
    .en( EN ),
    .Q( MEM_EX )
  );
  // addr
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i5 (
    .D( Addr_ID ),
    .C( clk ),
    .en( EN ),
    .Q( Addr_EX )
  );
  // FLAG_jalr
  DIG_Register DIG_Register_i6 (
    .D( Flag_ID ),
    .C( clk ),
    .en( EN ),
    .Q( Flag_EX )
  );
  // CSR
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i7 (
    .D( CSR_ID ),
    .C( clk ),
    .en( EN ),
    .Q( CSR_EX )
  );
  // IR
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i8 (
    .D( s0 ),
    .C( clk ),
    .en( EN ),
    .Q( ins_EX )
  );
endmodule
module PriorityEncoder2 (
    input in0,
    input in1,
    input in2,
    input in3,
    output reg [1:0] num,
    output any
);
    always @ (*) begin
        if (in3 == 1'b1)
            num = 2'h3;
        else if (in2 == 1'b1)
            num = 2'h2;
        else if (in1 == 1'b1)
            num = 2'h1;
        else 
            num = 2'h0;
    end

    assign any = in0 | in1 | in2 | in3;
endmodule
module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule

module branch_pre_2stage (
  input [31:0] ins_ID,
  input clk,
  input EN,
  input [31:0] rs1,
  input REGw,
  input [4:0] RDaddr,
  input jump_EX,
  input mret,
  input INT,
  input [31:0] PCjump,
  input [31:0] ISR,
  output Flag_jump,
  output [31:0] pc_ID,
  output [31:0] mepc
);
  wire [31:0] s0;
  wire [31:0] pc_ID_temp;
  wire s1;
  wire [12:0] s2;
  wire s3;
  wire [20:0] s4;
  wire [10:0] s5;
  wire [31:0] s6;
  wire [18:0] s7;
  wire [31:0] s8;
  wire [19:0] s9;
  wire [31:0] s10;
  wire s11;
  wire [1:0] sel;
  wire [31:0] s12;
  wire [31:0] s13;
  wire [31:0] s14;
  wire [31:0] s15;
  wire [31:0] s16;
  wire [31:0] s17;
  wire [4:0] s18;
  wire s19;
  wire s20;
  wire s21;
  wire [4:0] s22;
  wire s23;
  wire int_sel;
  wire [31:0] nextpc;
  wire [31:0] mepc_temp;
  wire s24;
  DIG_Register DIG_Register_i0 (
    .D( INT ),
    .C( clk ),
    .en( EN ),
    .Q( s24 )
  );
  assign s1 = ins_ID[31];
  assign s3 = ins_ID[31];
  assign s11 = ins_ID[31];
  assign s22 = ins_ID[19:15];
  assign s18 = ins_ID[6:2];
  assign s2[0] = 1'b0;
  assign s2[4:1] = ins_ID[11:8];
  assign s2[10:5] = ins_ID[30:25];
  assign s2[11] = ins_ID[7];
  assign s2[12] = s1;
  assign s4[0] = 1'b0;
  assign s4[10:1] = ins_ID[30:21];
  assign s4[11] = ins_ID[20];
  assign s4[19:12] = ins_ID[19:12];
  assign s4[20] = s3;
  DIG_BitExtenderSingle #(
    .outputBits(20)
  )
  DIG_BitExtenderSingle_i1 (
    .in( s11 ),
    .out( s9 )
  );
  DIG_BitExtenderSingle #(
    .outputBits(11)
  )
  DIG_BitExtenderSingle_i2 (
    .in( s3 ),
    .out( s5 )
  );
  DIG_BitExtenderSingle #(
    .outputBits(19)
  )
  DIG_BitExtenderSingle_i3 (
    .in( s1 ),
    .out( s7 )
  );
  // jal
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i4 (
    .a( s18 ),
    .b( 5'b11011 ),
    .\= ( s19 )
  );
  // bxx
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i5 (
    .a( s18 ),
    .b( 5'b11000 ),
    .\= ( s20 )
  );
  // jalr
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i6 (
    .a( s18 ),
    .b( 5'b11001 ),
    .\= ( s21 )
  );
  // rediect
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i7 (
    .a( s22 ),
    .b( RDaddr ),
    .\= ( s23 )
  );
  assign int_sel = (INT | (s24 & jump_EX));
  assign s6[20:0] = s4;
  assign s6[31:21] = s5;
  assign s8[12:0] = s2;
  assign s8[31:13] = s7;
  assign s10[11:0] = ins_ID[31:20];
  assign s10[31:12] = s9;
  // PCsel
  PriorityEncoder2 PriorityEncoder2_i8 (
    .in0( 1'b0 ),
    .in1( s20 ),
    .in2( s19 ),
    .in3( s21 ),
    .num( sel )
  );
  assign Flag_jump = (REGw & s23);
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i9 (
    .sel( s1 ),
    .in_0( 32'b100 ),
    .in_1( s8 ),
    .out( s12 )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i10 (
    .sel( sel ),
    .in_0( 32'b100 ),
    .in_1( s12 ),
    .in_2( s6 ),
    .in_3( s10 ),
    .out( s13 )
  );
  // pc
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i11 (
    .D( s0 ),
    .C( clk ),
    .en( EN ),
    .Q( pc_ID_temp )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i12 (
    .sel( sel ),
    .in_0( pc_ID_temp ),
    .in_1( pc_ID_temp ),
    .in_2( pc_ID_temp ),
    .in_3( rs1 ),
    .out( s14 )
  );
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i13 (
    .a( s14 ),
    .b( s13 ),
    .c_i( 1'b0 ),
    .s( s15 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i14 (
    .sel( jump_EX ),
    .in_0( s16 ),
    .in_1( PCjump ),
    .out( s17 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i15 (
    .sel( int_sel ),
    .in_0( nextpc ),
    .in_1( ISR ),
    .out( s0 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i16 (
    .sel( mret ),
    .in_0( s17 ),
    .in_1( mepc_temp ),
    .out( nextpc )
  );
  // mepc
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i17 (
    .D( nextpc ),
    .C( clk ),
    .en( int_sel ),
    .Q( mepc_temp )
  );
  assign s16[31:2] = s15[31:2];
  assign s16[1:0] = 2'b0;
  assign pc_ID = pc_ID_temp;
  assign mepc = mepc_temp;
endmodule

module \r&w  (
  input OP6,
  input OP5,
  input OP4,
  input OP3,
  input OP2,
  output mr,
  output mw,
  output csrw,
  output rw
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  assign s4 = ~ OP6;
  assign s3 = ~ OP5;
  assign s2 = ~ OP4;
  assign s1 = ~ OP3;
  assign s0 = ~ OP2;
  assign mr = (s0 & s1 & s2 & s3 & s4);
  assign mw = (s0 & s1 & s2 & OP5 & s4);
  assign csrw = (s0 & s1 & OP4 & OP5 & OP6);
  assign rw = ((s0 & s1 & OP4 & OP5) | (s0 & s1 & s3 & s4) | (OP2 & s2 & OP5 & OP6) | (s1 & OP4 & s4));
endmodule

module alusel (
  input op6,
  input op5,
  input op4,
  input op3,
  input op2,
  input F2,
  input F1,
  input F0,
  output asel3,
  output asel2,
  output asel1,
  output asel0
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  assign s4 = ~ op6;
  assign s5 = ~ op5;
  assign s7 = ~ op4;
  assign s3 = ~ op3;
  assign s2 = ~ op2;
  assign s1 = ~ F2;
  assign s6 = ~ F1;
  assign s0 = ~ F0;
  assign asel3 = ((s0 & s1 & s2 & s3 & s4) | (s0 & s2 & s3 & s5 & s4) | (s6 & s1 & s2 & s3 & s7 & op5) | (s6 & s2 & s3 & s5 & s4) | (F2 & s3 & s7 & op5 & op6) | (op2 & s7 & op5 & op6) | (s3 & op4 & s4));
  assign asel2 = ((F0 & s6 & s2 & s3 & op5 & op6) | (F1 & F2 & s2 & s3 & op5 & op6) | (F1 & s2 & s3 & op4 & op5) | (s6 & s3 & s7 & op5 & op6) | (op2 & s3 & op4 & s4) | (op2 & s7 & op5 & op6) | (s3 & op4 & op5 & s4));
  assign asel1 = ((s0 & s1 & s2 & s3 & s7 & op5 & s4) | (F0 & s1 & s2 & s3 & op4 & op5 & op6) | (F0 & s6 & s3 & op4 & s5 & s4) | (s6 & s1 & s2 & s3 & s7 & op5 & s4) | (F1 & s1 & s2 & s3 & op4 & op5 & op6) | (op2 & s3 & op4 & s4) | (op2 & s7 & op5 & op6));
  assign asel0 = ((F0 & F1 & s2 & s3 & op4 & op5 & op6) | (F0 & s6 & s2 & s3 & op4 & s4) | (op2 & s7 & op5 & op6));
endmodule

module aluop (
  input op6,
  input op5,
  input op4,
  input op3,
  input op2,
  input F2,
  input F1,
  input F0,
  input b,
  output aop3,
  output aop2,
  output aop1,
  output aop0
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  assign s3 = ~ op6;
  assign s6 = ~ op4;
  assign s2 = ~ op3;
  assign s1 = ~ op2;
  assign s5 = ~ F2;
  assign s0 = ~ F1;
  assign s4 = ~ F0;
  assign aop3 = ((F0 & s0 & F2 & b & s1 & s2 & op4 & s3) | (s4 & s0 & s5 & b & s2 & op4 & op5 & s3) | (F0 & F2 & s1 & s2 & s6 & op5 & op6) | (F0 & s0 & s1 & s2 & op5 & op6) | (s0 & s5 & s1 & s2 & s6 & op5 & op6) | (op2 & s2 & op4 & op5 & s3));
  assign aop2 = ((s0 & s5 & s1 & s2 & s6 & op5 & op6) | (F1 & s1 & s2 & op4 & op5 & op6) | (F2 & s1 & s2 & op4 & s3) | (op2 & s2 & op4 & op5 & s3));
  assign aop1 = ((s4 & s0 & s1 & s2 & s6 & op5 & op6) | (F1 & s1 & s2 & op4 & op5) | (F1 & s1 & s2 & op4 & s3) | (F2 & s1 & s2 & s6 & op5 & op6) | (op2 & s2 & op4 & op5 & s3));
  assign aop0 = ((F0 & s1 & s2 & op4 & op5) | (F0 & s1 & s2 & op4 & s3) | (F1 & F2 & s1 & s2 & s6 & op5 & op6) | (op2 & s2 & op4 & op5 & s3));
endmodule

module EX_controller (
  input [31:0] ins_EX,
  output regw,
  output [11:0] csraddr,
  output [4:0] RDa,
  output [2:0] rwsel,
  output brk,
  output csrw,
  output mw,
  output [3:0] alusel,
  output [3:0] aluop
);
  wire [4:0] RDa_temp;
  wire [4:0] op;
  wire [2:0] funct3;
  wire branch;
  wire s0;
  wire csrw_temp;
  wire mw_temp;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire [2:0] s10;
  wire [2:0] s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire s16;
  wire s17;
  wire s18;
  wire s19;
  wire s20;
  wire s21;
  wire s22;
  wire s23;
  wire s24;
  wire s25;
  wire s26;
  wire s27;
  wire s28;
  wire s29;
  wire s30;
  wire s31;
  wire s32;
  wire s33;
  wire s34;
  wire s35;
  assign op = ins_EX[6:2];
  assign RDa_temp = ins_EX[11:7];
  assign funct3 = ins_EX[14:12];
  assign branch = ins_EX[30];
  assign csraddr = ins_EX[31:20];
  assign s1 = (funct3[0] | funct3[1] | funct3[2]);
  assign s3 = op[4];
  assign s4 = op[3];
  assign s5 = op[2];
  assign s6 = op[1];
  assign s7 = op[0];
  assign s12 = op[4];
  assign s13 = op[3];
  assign s14 = op[2];
  assign s15 = op[1];
  assign s16 = op[0];
  assign s17 = funct3[2];
  assign s18 = funct3[1];
  assign s19 = funct3[0];
  assign s24 = op[4];
  assign s25 = op[3];
  assign s26 = op[2];
  assign s27 = op[1];
  assign s28 = op[0];
  assign s29 = funct3[2];
  assign s30 = funct3[1];
  assign s31 = funct3[0];
  \r&w  \r&w_i0 (
    .OP6( s3 ),
    .OP5( s4 ),
    .OP4( s5 ),
    .OP3( s6 ),
    .OP2( s7 ),
    .mr( s8 ),
    .mw( mw_temp ),
    .csrw( s2 ),
    .rw( s0 )
  );
  alusel alusel_i1 (
    .op6( s12 ),
    .op5( s13 ),
    .op4( s14 ),
    .op3( s15 ),
    .op2( s16 ),
    .F2( s17 ),
    .F1( s18 ),
    .F0( s19 ),
    .asel3( s20 ),
    .asel2( s21 ),
    .asel1( s22 ),
    .asel0( s23 )
  );
  aluop aluop_i2 (
    .op6( s24 ),
    .op5( s25 ),
    .op4( s26 ),
    .op3( s27 ),
    .op2( s28 ),
    .F2( s29 ),
    .F1( s30 ),
    .F0( s31 ),
    .b( branch ),
    .aop3( s32 ),
    .aop2( s33 ),
    .aop1( s34 ),
    .aop0( s35 )
  );
  assign regw = (s0 & (RDa_temp[0] | RDa_temp[1] | RDa_temp[2] | RDa_temp[3] | RDa_temp[4]));
  assign brk = (~ s1 & s2 & ins_EX[20]);
  assign csrw_temp = (s2 & s1);
  assign s9 = (s8 | mw_temp);
  assign alusel[3] = s20;
  assign alusel[2] = s21;
  assign alusel[1] = s22;
  assign alusel[0] = s23;
  assign aluop[3] = s32;
  assign aluop[2] = s33;
  assign aluop[1] = s34;
  assign aluop[0] = s35;
  DIG_BitExtenderSingle #(
    .outputBits(3)
  )
  DIG_BitExtenderSingle_i3 (
    .in( s9 ),
    .out( s10 )
  );
  DIG_BitExtenderSingle #(
    .outputBits(3)
  )
  DIG_BitExtenderSingle_i4 (
    .in( csrw_temp ),
    .out( s11 )
  );
  assign rwsel = ~ ((3'b100 & s11) | (~ funct3 & s10));
  assign RDa = RDa_temp;
  assign csrw = csrw_temp;
  assign mw = mw_temp;
endmodule

module preALU (
  input [3:0] alusel, // aluX input
  input [31:0] pc_alu,
  input [31:0] ins_alu, // instruction
  input [31:0] rs1,
  input [31:0] rs2,
  input [31:0] csr,
  output [31:0] x,
  output [31:0] y
);
  wire [31:0] s0;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  wire [31:0] s4;
  wire [31:0] s5;
  wire [19:0] s6;
  wire [31:0] s7;
  wire s8;
  wire s9;
  wire [31:0] s10;
  wire [31:0] s11;
  wire s12;
  wire [31:0] s13;
  wire [31:0] s14;
  wire s15;
  wire [31:0] s16;
  wire [1:0] s17;
  wire [31:0] s18;
  wire [1:0] s19;
  wire [1:0] s20;
  assign s0[4:0] = ins_alu[19:15];
  assign s0[31:5] = 27'b0;
  assign s1[4:0] = ins_alu[24:20];
  assign s1[31:5] = 27'b0;
  assign s2[31:12] = ins_alu[31:12];
  assign s2[11:0] = 12'b0;
  assign s3[4:0] = rs2[4:0];
  assign s3[31:5] = 27'b0;
  assign s4 = ~ rs1;
  assign s8 = ins_alu[31];
  assign s9 = alusel[0];
  assign s12 = alusel[1];
  assign s19 = alusel[3:2];
  assign s15 = alusel[1];
  assign s17 = alusel[1:0];
  assign s20 = alusel[3:2];
  assign s5 = ~ s0;
  DIG_BitExtenderSingle #(
    .outputBits(20)
  )
  DIG_BitExtenderSingle_i0 (
    .in( s8 ),
    .out( s6 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i1 (
    .sel( s9 ),
    .in_0( rs2 ),
    .in_1( s3 ),
    .out( s10 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i2 (
    .sel( s9 ),
    .in_0( s2 ),
    .in_1( 32'b100 ),
    .out( s11 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i3 (
    .sel( s15 ),
    .in_0( rs1 ),
    .in_1( pc_alu ),
    .out( s16 )
  );
  assign s7[11:0] = ins_alu[31:20];
  assign s7[31:12] = s6;
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i4 (
    .sel( s12 ),
    .in_0( s10 ),
    .in_1( s11 ),
    .out( s13 )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i5 (
    .sel( s17 ),
    .in_0( s0 ),
    .in_1( s5 ),
    .in_2( rs1 ),
    .in_3( s4 ),
    .out( s18 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i6 (
    .sel( s12 ),
    .in_0( s7 ),
    .in_1( s1 ),
    .out( s14 )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i7 (
    .sel( s20 ),
    .in_0( 32'b0 ),
    .in_1( s18 ),
    .in_2( rs1 ),
    .in_3( s16 ),
    .out( x )
  );
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i8 (
    .sel( s19 ),
    .in_0( 32'b0 ),
    .in_1( csr ),
    .in_2( s14 ),
    .in_3( s13 ),
    .out( y )
  );
endmodule
module DIG_ROM_512X32_Irom (
    input [8:0] A,
    input sel,
    output reg [31:0] D
);
    reg [31:0] my_rom [0:10];

    always @ (*) begin
        if (~sel)
            D = 32'hz;
        else if (A > 9'ha)
            D = 32'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 32'h100593;
        my_rom[1] = 32'hfff5c613;
        my_rom[2] = 32'h40165613;
        my_rom[3] = 32'hb606b3;
        my_rom[4] = 32'hc6b533;
        my_rom[5] = 32'h587b3;
        my_rom[6] = 32'hfffff737;
        my_rom[7] = 32'hf70733;
        my_rom[8] = 32'h479793;
        my_rom[9] = 32'h33079073;
        my_rom[10] = 32'hfe074ae3;
    end
endmodule
module DIG_ROM_256X32_Drom (
    input [7:0] A,
    input sel,
    output reg [31:0] D
);
    reg [31:0] my_rom [0:44];

    always @ (*) begin
        if (~sel)
            D = 32'hz;
        else if (A > 8'h2c)
            D = 32'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 32'h0;
        my_rom[1] = 32'hfffff0b7;
        my_rom[2] = 32'h400093;
        my_rom[3] = 32'h40016f;
        my_rom[4] = 32'h158513;
        my_rom[5] = 32'hfeb50fe3;
        my_rom[6] = 32'hfff20193;
        my_rom[7] = 32'h318233;
        my_rom[8] = 32'h308023;
        my_rom[9] = 32'h309023;
        my_rom[10] = 32'h30a023;
        my_rom[11] = 32'h40a223;
        my_rom[12] = 32'h402383;
        my_rom[13] = 32'h800403;
        my_rom[14] = 32'h801403;
        my_rom[15] = 32'h804403;
        my_rom[16] = 32'h805403;
        my_rom[17] = 32'h802403;
        my_rom[18] = 32'hff3a413;
        my_rom[19] = 32'hffe3b413;
        my_rom[20] = 32'hfff44413;
        my_rom[21] = 32'h247493;
        my_rom[22] = 32'h249513;
        my_rom[23] = 32'h1f4d593;
        my_rom[24] = 32'h25d593;
        my_rom[25] = 32'h40125613;
        my_rom[26] = 32'h40460633;
        my_rom[27] = 32'hc616b3;
        my_rom[28] = 32'hc42733;
        my_rom[29] = 32'hc43733;
        my_rom[30] = 32'h864733;
        my_rom[31] = 32'he6d7b3;
        my_rom[32] = 32'h40f75733;
        my_rom[33] = 32'hd77733;
        my_rom[34] = 32'hc76833;
        my_rom[35] = 32'h200713;
        my_rom[36] = 32'h11d873;
        my_rom[37] = 32'h11d873;
        my_rom[38] = 32'h810f3;
        my_rom[39] = 32'h710f3;
        my_rom[40] = 32'ha973;
        my_rom[41] = 32'h25973;
        my_rom[42] = 32'h1039f3;
        my_rom[43] = 32'h10f9f3;
        my_rom[44] = 32'he7;
    end
endmodule
module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule
module CompSigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = $signed(a) > $signed(b);
    assign \= = $signed(a) == $signed(b);
    assign \< = $signed(a) < $signed(b);
endmodule
module LogicalLeft #(
parameter Bits = 4,
parameter shiftBits=3
)
(
    input [(Bits-1):0] in,
    input [(shiftBits-1):0] shift,
    output [(Bits - 1):0] out
);

assign out = (in << shift);

endmodule
module LogicalRight #(
parameter Bits = 4,
parameter shiftBits=3
)
(
    input [(Bits-1):0] in,
    input [(shiftBits-1):0] shift,
    output [(Bits - 1):0] out
);

assign out = (in >> shift);

endmodule
module ArithmeticRight #(
parameter Bits = 4,
parameter shiftBits=3
)
(
    input [(Bits-1):0] in,
    input [(shiftBits-1):0] shift,
    output [(Bits - 1):0] out
);

assign out=($signed(in)>>>shift);

endmodule
module Mux_16x1_NBits #(
    parameter Bits = 2
)
(
    input [3:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    input [(Bits - 1):0] in_8,
    input [(Bits - 1):0] in_9,
    input [(Bits - 1):0] in_10,
    input [(Bits - 1):0] in_11,
    input [(Bits - 1):0] in_12,
    input [(Bits - 1):0] in_13,
    input [(Bits - 1):0] in_14,
    input [(Bits - 1):0] in_15,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            4'h0: out = in_0;
            4'h1: out = in_1;
            4'h2: out = in_2;
            4'h3: out = in_3;
            4'h4: out = in_4;
            4'h5: out = in_5;
            4'h6: out = in_6;
            4'h7: out = in_7;
            4'h8: out = in_8;
            4'h9: out = in_9;
            4'ha: out = in_10;
            4'hb: out = in_11;
            4'hc: out = in_12;
            4'hd: out = in_13;
            4'he: out = in_14;
            4'hf: out = in_15;
            default:
                out = 'h0;
        endcase
    end
endmodule

module ALU (
  input [3:0] aluop,
  input [31:0] x,
  input [31:0] y,
  output [31:0] aluR
);
  wire [31:0] addx;
  wire [31:0] sub;
  wire [31:0] andx;
  wire [31:0] orx;
  wire [31:0] xorx;
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire [5:0] s6;
  wire [31:0] bge;
  wire [31:0] bgeu;
  wire [31:0] bne;
  wire [31:0] \sltx&blt ;
  wire [31:0] beq;
  wire [31:0] \sltxu&bltu ;
  wire [31:0] sllx;
  wire [31:0] srlx;
  wire [31:0] srax;
  // +
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i0 (
    .a( x ),
    .b( y ),
    .c_i( 1'b0 ),
    .s( addx )
  );
  // -
  DIG_Sub #(
    .Bits(32)
  )
  DIG_Sub_i1 (
    .a( x ),
    .b( y ),
    .c_i( 1'b0 ),
    .s( sub )
  );
  assign andx = (x & y);
  assign orx = (x | y);
  assign xorx = (x ^ y);
  // s>=<
  CompSigned #(
    .Bits(32)
  )
  CompSigned_i2 (
    .a( x ),
    .b( y ),
    .\> ( s0 ),
    .\= ( s1 ),
    .\< ( s2 )
  );
  // >=<
  CompUnsigned #(
    .Bits(32)
  )
  CompUnsigned_i3 (
    .a( x ),
    .b( y ),
    .\> ( s3 ),
    .\= ( s4 ),
    .\< ( s5 )
  );
  assign s6 = y[5:0];
  assign bge[0] = (s0 | s1);
  assign bge[31:1] = 31'b0;
  assign bgeu[0] = (s3 | s4);
  assign bgeu[31:1] = 31'b0;
  assign bne[0] = ~ s4;
  assign bne[31:1] = 31'b0;
  assign \sltx&blt [0] = s2;
  assign \sltx&blt [31:1] = 31'b0;
  assign beq[0] = s1;
  assign beq[31:1] = 31'b0;
  assign \sltxu&bltu [0] = s5;
  assign \sltxu&bltu [31:1] = 31'b0;
  // LeftL
  LogicalLeft #(
    .Bits(32),
    .shiftBits(6)
  )
  LogicalLeft_i4 (
    .in( x ),
    .shift( s6 ),
    .out( sllx )
  );
  // RightL
  LogicalRight #(
    .Bits(32),
    .shiftBits(6)
  )
  LogicalRight_i5 (
    .in( x ),
    .shift( s6 ),
    .out( srlx )
  );
  // RightA
  ArithmeticRight #(
    .Bits(32),
    .shiftBits(6)
  )
  ArithmeticRight_i6 (
    .in( x ),
    .shift( s6 ),
    .out( srax )
  );
  Mux_16x1_NBits #(
    .Bits(32)
  )
  Mux_16x1_NBits_i7 (
    .sel( aluop ),
    .in_0( addx ),
    .in_1( sllx ),
    .in_2( \sltx&blt  ),
    .in_3( \sltxu&bltu  ),
    .in_4( xorx ),
    .in_5( srlx ),
    .in_6( orx ),
    .in_7( andx ),
    .in_8( sub ),
    .in_9( x ),
    .in_10( bge ),
    .in_11( bgeu ),
    .in_12( bne ),
    .in_13( srax ),
    .in_14( beq ),
    .in_15( y ),
    .out( aluR )
  );
endmodule

module HALT (
  input clk,
  input mw_EX,
  input [31:0] ins_ID,
  output EN,
  output memw
);
  wire [4:0] op;
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  assign s1 = ~ clk;
  assign op = ins_ID[6:2];
  // sx
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i0 (
    .a( op ),
    .b( 5'b1000 ),
    .\= ( s8 )
  );
  // lx
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i1 (
    .a( op ),
    .b( 5'b0 ),
    .\= ( s9 )
  );
  assign s7 = (s8 | s9);
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i2 (
    .Set( 1'b0 ),
    .D( s7 ),
    .C( s1 ),
    .Clr( 1'b0 ),
    .\~Q ( s5 )
  );
  // delay1
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i3 (
    .Set( 1'b0 ),
    .D( s0 ),
    .C( s1 ),
    .Clr( 1'b0 ),
    .Q( s2 ),
    .\~Q ( s3 )
  );
  assign memw = (s4 & mw_EX);
  assign EN = (s5 | s4);
  assign s0 = (s4 & mw_EX);
  // delay2
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i4 (
    .Set( 1'b0 ),
    .D( s2 ),
    .C( s1 ),
    .Clr( 1'b0 ),
    .\~Q ( s6 )
  );
  assign s4 = (s3 & s6);
endmodule
module DIG_RAMDualPort
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
  input [(AddrBits-1):0] A,
  input [(Bits-1):0] Din,
  input str,
  input C,
  input ld,
  output [(Bits-1):0] D
);
  reg [(Bits-1):0] memory[0:((1 << AddrBits) - 1)];

  assign D = ld? memory[A] : 'hz;

  always @ (posedge C) begin
    if (str)
      memory[A] <= Din;
  end
endmodule

module judge_branch (
  input [31:0] PC,
  input [31:0] ins_EX,
  input bxx,
  input Flag,
  input [31:0] rs1,
  output [31:0] PC_jump,
  output jump_EX
);
  wire s0;
  wire [12:0] s1;
  wire [18:0] s2;
  wire [31:0] s3;
  wire [31:0] s4;
  wire [31:0] s5;
  wire [4:0] s6;
  wire s7;
  wire s8;
  wire s9;
  wire [19:0] s10;
  wire [31:0] s11;
  wire [31:0] s12;
  wire [31:0] s13;
  wire s14;
  wire [31:0] s15;
  assign s0 = ins_EX[31];
  assign s9 = ins_EX[31];
  assign s6 = ins_EX[6:2];
  assign s1[1:0] = 2'b0;
  assign s1[4:2] = ins_EX[11:9];
  assign s1[10:5] = ins_EX[30:25];
  assign s1[11] = ins_EX[7];
  assign s1[12] = s0;
  DIG_BitExtenderSingle #(
    .outputBits(19)
  )
  DIG_BitExtenderSingle_i0 (
    .in( s0 ),
    .out( s2 )
  );
  // bxx
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i1 (
    .a( s6 ),
    .b( 5'b11000 ),
    .\= ( s7 )
  );
  DIG_BitExtenderSingle #(
    .outputBits(20)
  )
  DIG_BitExtenderSingle_i2 (
    .in( s9 ),
    .out( s10 )
  );
  // jalr_EX
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i3 (
    .a( s6 ),
    .b( 5'b11001 ),
    .\= ( s14 )
  );
  assign s3[12:0] = s1;
  assign s3[31:13] = s2;
  assign s8 = ((s0 ^ bxx) & s7);
  assign s11[11:0] = ins_EX[31:20];
  assign s11[31:12] = s10;
  // EX_jalr
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i4 (
    .a( s11 ),
    .b( rs1 ),
    .c_i( 1'b0 ),
    .s( s15 )
  );
  assign jump_EX = (s8 | (Flag & s14));
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i5 (
    .sel( s0 ),
    .in_0( s3 ),
    .in_1( 32'b100 ),
    .out( s4 )
  );
  // EX_bxx
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i6 (
    .a( s4 ),
    .b( PC ),
    .c_i( 1'b0 ),
    .s( s5 )
  );
  assign s12[31:2] = s15[31:2];
  assign s12[1:0] = 2'b0;
  assign s13[31:2] = s5[31:2];
  assign s13[1:0] = 2'b0;
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i7 (
    .sel( s8 ),
    .in_0( s12 ),
    .in_1( s13 ),
    .out( PC_jump )
  );
endmodule

module preRW (
  input [31:0] aluR,
  input [2:0] sel,
  input [31:0] ramData,
  input [31:0] csrData,
  output [31:0] rwData
);
  wire s0;
  wire [23:0] s1;
  wire [23:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [1:0] s5;
  wire [31:0] s6;
  wire [31:0] s7;
  wire [31:0] s8;
  wire [31:0] s9;
  wire [7:0] s10;
  wire [15:0] s11;
  wire s12;
  wire s13;
  assign s10 = ramData[7:0];
  assign s11 = ramData[15:0];
  assign s8 = ramData[31:0];
  assign s0 = sel[2];
  assign s5 = sel[1:0];
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i0 (
    .sel( s0 ),
    .in_0( csrData ),
    .in_1( aluR ),
    .out( s9 )
  );
  assign s12 = s11[15];
  assign s13 = s10[7];
  DIG_BitExtenderSingle #(
    .outputBits(16)
  )
  DIG_BitExtenderSingle_i1 (
    .in( s12 ),
    .out( s3 )
  );
  DIG_BitExtenderSingle #(
    .outputBits(24)
  )
  DIG_BitExtenderSingle_i2 (
    .in( s13 ),
    .out( s1 )
  );
  Mux_2x1_NBits #(
    .Bits(24)
  )
  Mux_2x1_NBits_i3 (
    .sel( s0 ),
    .in_0( s1 ),
    .in_1( 24'b0 ),
    .out( s2 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i4 (
    .sel( s0 ),
    .in_0( s3 ),
    .in_1( 16'b0 ),
    .out( s4 )
  );
  assign s7[15:0] = s11;
  assign s7[31:16] = s4;
  assign s6[7:0] = s10;
  assign s6[31:8] = s2;
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i5 (
    .sel( s5 ),
    .in_0( s6 ),
    .in_1( s7 ),
    .in_2( s8 ),
    .in_3( s9 ),
    .out( rwData )
  );
endmodule
module DIG_RegisterFile
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input [(Bits-1):0] Din,
    input we,
    input [(AddrBits-1):0] Rw,
    input C,
    input [(AddrBits-1):0] Ra,
    input [(AddrBits-1):0] Rb,
    output [(Bits-1):0] Da,
    output [(Bits-1):0] Db
);

    reg [(Bits-1):0] memory[0:((1 << AddrBits)-1)];

    assign Da = memory[Ra];
    assign Db = memory[Rb];

    always @ (posedge C) begin
        if (we)
            memory[Rw] <= Din;
    end
endmodule

module redirect (
  input [31:0] ins_ID,
  input [31:0] rs1_ID,
  input [31:0] rs2_ID,
  input regw,
  input [4:0] rd_addr,
  input [31:0] rd_EX,
  output [31:0] RS1,
  output [31:0] RS2
);
  wire [4:0] s0;
  wire [4:0] s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  assign s0 = ins_ID[19:15];
  assign s1 = ins_ID[24:20];
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i0 (
    .a( s0 ),
    .b( rd_addr ),
    .\= ( s2 )
  );
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i1 (
    .a( s1 ),
    .b( rd_addr ),
    .\= ( s3 )
  );
  assign s4 = (regw & s2);
  assign s5 = (regw & s3);
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i2 (
    .sel( s4 ),
    .in_0( rs1_ID ),
    .in_1( rd_EX ),
    .out( RS1 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i3 (
    .sel( s5 ),
    .in_0( rs2_ID ),
    .in_1( rd_EX ),
    .out( RS2 )
  );
endmodule

module preMW (
  input [31:0] ins_ID,
  input [31:0] rs1,
  input [31:0] rs2,
  output [31:0] mData,
  output [31:0] mAddr
);
  wire [1:0] s0;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  wire [11:0] s4;
  wire [19:0] s5;
  wire [31:0] s6;
  wire [19:0] s7;
  wire [31:0] s8;
  wire s9;
  wire s10;
  wire [31:0] s11;
  wire [4:0] s12;
  assign s4[11:5] = ins_ID[31:25];
  assign s4[4:0] = ins_ID[11:7];
  assign s2[15:0] = rs2[15:0];
  assign s2[31:16] = 16'b0;
  assign s1[7:0] = rs2[7:0];
  assign s1[31:8] = 24'b0;
  assign s9 = ins_ID[31];
  assign s3 = rs2[31:0];
  assign s12 = ins_ID[6:2];
  assign s0 = ins_ID[13:12];
  Mux_4x1_NBits #(
    .Bits(32)
  )
  Mux_4x1_NBits_i0 (
    .sel( s0 ),
    .in_0( s1 ),
    .in_1( s2 ),
    .in_2( s3 ),
    .in_3( 32'b0 ),
    .out( mData )
  );
  DIG_BitExtenderSingle #(
    .outputBits(20)
  )
  DIG_BitExtenderSingle_i1 (
    .in( s9 ),
    .out( s5 )
  );
  DIG_BitExtenderSingle #(
    .outputBits(20)
  )
  DIG_BitExtenderSingle_i2 (
    .in( s9 ),
    .out( s7 )
  );
  // sx
  CompUnsigned #(
    .Bits(5)
  )
  CompUnsigned_i3 (
    .a( s12 ),
    .b( 5'b1000 ),
    .\= ( s10 )
  );
  assign s6[11:0] = ins_ID[31:20];
  assign s6[31:12] = s5;
  assign s8[11:0] = s4;
  assign s8[31:12] = s7;
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i4 (
    .sel( s10 ),
    .in_0( s6 ),
    .in_1( s8 ),
    .out( s11 )
  );
  // +
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i5 (
    .a( s11 ),
    .b( rs1 ),
    .c_i( 1'b0 ),
    .s( mAddr )
  );
endmodule

module out (
  input clock,
  input reset,
  input key,
  output [31:0] OUT,
  output [31:0] ttime,
  output [31:0] mtcmp,
  output [31:0] pc,
  output [31:0] ins
);
  wire [3:0] s0;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  wire [3:0] s4;
  wire [31:0] s5;
  wire [31:0] s6;
  wire [31:0] s7;
  wire [31:0] s8;
  wire [31:0] s9;
  wire [8:0] s10;
  wire [31:0] ins_temp;
  wire [31:0] pc_temp;
  wire [7:0] s11;
  wire [31:0] s12;
  wire s13;
  wire s14;
  wire [31:0] s15;
  wire clk;
  wire [31:0] s16;
  wire Rw;
  wire [4:0] RDa;
  wire [4:0] s17;
  wire [4:0] s18;
  wire [31:0] RS1_ID;
  wire [31:0] RS2_ID;
  wire [31:0] s19;
  wire s20;
  wire [31:0] s21;
  wire [31:0] s22;
  wire bxx;
  wire s23;
  wire EN;
  wire [31:0] RS1;
  wire [31:0] RS2;
  wire Flag_ID;
  wire [31:0] s24;
  wire [31:0] s25;
  wire [31:0] s26;
  wire Flag_EX;
  wire [11:0] CSRa;
  wire [2:0] wsel;
  wire brk;
  wire CSRw;
  wire Mw_EX;
  wire mw;
  wire [31:0] s27;
  wire [31:0] s28;
  wire int;
  wire mret;
  wire J_EX;
  wire [31:0] s29;
  wire s30;
  wire s31;
  CSR CSR_i0 (
    .ins_ID( ins_temp ),
    .aluR( s3 ),
    .mepc( s27 ),
    .Wa( CSRa ),
    .clk( clock ),
    .W_EN( CSRw ),
    .EN( EN ),
    .ExInt( key ),
    .ISR( s28 ),
    .CSR( s24 ),
    .INT( int ),
    .OUT( OUT ),
    .mret( mret ),
    .test_1( ttime ),
    .test_2( mtcmp )
  );
  assign s30 = (clock & (int | reset));
  ID_EX ID_EX_i1 (
    .clr( s23 ),
    .PC_ID( pc_temp ),
    .ins_ID( ins_temp ),
    .clk( clk ),
    .EN( EN ),
    .RS1_ID( RS1 ),
    .RS2_ID( RS2 ),
    .Flag_ID( Flag_ID ),
    .CSR_ID( s24 ),
    .MEM_ID( s25 ),
    .Addr_ID( s26 ),
    .PC_EX( s5 ),
    .ins_EX( s6 ),
    .RS1_EX( s7 ),
    .RS2_EX( s8 ),
    .CSR_EX( s9 ),
    .MEM_EX( s12 ),
    .Addr_EX( s22 ),
    .Flag_EX( Flag_EX )
  );
  branch_pre_2stage branch_pre_2stage_i2 (
    .ins_ID( ins_temp ),
    .clk( clk ),
    .EN( EN ),
    .rs1( RS1_ID ),
    .REGw( Rw ),
    .RDaddr( RDa ),
    .jump_EX( J_EX ),
    .mret( mret ),
    .INT( int ),
    .PCjump( s29 ),
    .ISR( s28 ),
    .Flag_jump( Flag_ID ),
    .pc_ID( pc_temp ),
    .mepc( s27 )
  );
  // break
  DIG_D_FF_AS_1bit #(
    .Default(0)
  )
  DIG_D_FF_AS_1bit_i3 (
    .Set( 1'b0 ),
    .D( brk ),
    .C( clk ),
    .Clr( s30 ),
    .Q( s31 )
  );
  EX_controller EX_controller_i4 (
    .ins_EX( s6 ),
    .regw( Rw ),
    .csraddr( CSRa ),
    .RDa( RDa ),
    .rwsel( wsel ),
    .brk( brk ),
    .csrw( CSRw ),
    .mw( Mw_EX ),
    .alusel( s4 ),
    .aluop( s0 )
  );
  assign clk = (clock | s31);
  assign s10 = pc_temp[10:2];
  assign s20 = s22[10];
  assign s11 = s22[9:2];
  preALU preALU_i5 (
    .alusel( s4 ),
    .pc_alu( s5 ),
    .ins_alu( s6 ),
    .rs1( s7 ),
    .rs2( s8 ),
    .csr( s9 ),
    .x( s1 ),
    .y( s2 )
  );
  // Irom
  DIG_ROM_512X32_Irom DIG_ROM_512X32_Irom_i6 (
    .A( s10 ),
    .sel( 1'b1 ),
    .D( ins_temp )
  );
  assign s14 = ~ clk;
  // Drom
  DIG_ROM_256X32_Drom DIG_ROM_256X32_Drom_i7 (
    .A( s11 ),
    .sel( 1'b1 ),
    .D( s19 )
  );
  ALU ALU_i8 (
    .aluop( s0 ),
    .x( s1 ),
    .y( s2 ),
    .aluR( s3 )
  );
  HALT HALT_i9 (
    .clk( clk ),
    .mw_EX( Mw_EX ),
    .ins_ID( ins_temp ),
    .EN( EN ),
    .memw( mw )
  );
  assign s17 = ins_temp[19:15];
  assign s18 = ins_temp[24:20];
  assign s13 = (mw & s20);
  assign bxx = s3[0];
  // Dram
  DIG_RAMDualPort #(
    .Bits(32),
    .AddrBits(8)
  )
  DIG_RAMDualPort_i10 (
    .A( s11 ),
    .Din( s12 ),
    .str( s13 ),
    .C( s14 ),
    .ld( 1'b1 ),
    .D( s15 )
  );
  judge_branch judge_branch_i11 (
    .PC( s5 ),
    .ins_EX( s6 ),
    .bxx( bxx ),
    .Flag( Flag_EX ),
    .rs1( s7 ),
    .PC_jump( s29 ),
    .jump_EX( J_EX )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i12 (
    .sel( s20 ),
    .in_0( s19 ),
    .in_1( s15 ),
    .out( s21 )
  );
  assign s23 = (~ (ins_temp[0] & ins_temp[1]) | J_EX);
  preRW preRW_i13 (
    .aluR( s3 ),
    .sel( wsel ),
    .ramData( s21 ),
    .csrData( s9 ),
    .rwData( s16 )
  );
  // regs
  DIG_RegisterFile #(
    .Bits(32),
    .AddrBits(5)
  )
  DIG_RegisterFile_i14 (
    .Din( s16 ),
    .we( Rw ),
    .Rw( RDa ),
    .C( clk ),
    .Ra( s17 ),
    .Rb( s18 ),
    .Da( RS1_ID ),
    .Db( RS2_ID )
  );
  redirect redirect_i15 (
    .ins_ID( ins_temp ),
    .rs1_ID( RS1_ID ),
    .rs2_ID( RS2_ID ),
    .regw( Rw ),
    .rd_addr( RDa ),
    .rd_EX( s16 ),
    .RS1( RS1 ),
    .RS2( RS2 )
  );
  preMW preMW_i16 (
    .ins_ID( ins_temp ),
    .rs1( RS1 ),
    .rs2( RS2 ),
    .mData( s25 ),
    .mAddr( s26 )
  );
  assign pc = pc_temp;
  assign ins = ins_temp;
endmodule
